<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WAR! Campaign — Strategic Board</title>

<style>
  :root{
    --bg:#2b2721;
    --paper:#3a342c;
    --ink:#e9e3d7;
    --line:#6b5b3e;
    --muted:#bdb6a8;

    --allies:#c9b27c;
    --axis:#666666;
    --ussr:#b22222;
    --neutral:#888888;
    --custom:#d9d9d9;

    --weTint: rgba(201,178,124,.10);
    --eeTint: rgba(178,34,34,.10);
    --naTint: rgba(224,176,122,.10);
    --paTint: rgba(122,160,224,.10);
  }

  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;}
  #topbar{
    position:fixed; inset:0 0 auto 0; z-index:1000;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    padding:10px 12px; background:#1b1b1b; border-bottom:2px solid #444;
  }
  #topbar .title{font-weight:700; letter-spacing:1px; margin-right:auto;}
  #topbar button, #topbar select{
    background:#222; color:#eee; border:1px solid #555; padding:6px 10px; cursor:pointer;
  }
  #topbar button:hover{background:#333;}
  #topbar .smallLabel{color:var(--muted);font-size:12px;}

  #wrap{
    position:absolute; top:64px; left:0; right:430px; bottom:0;
    overflow:auto;
    background:
      radial-gradient(circle at 20% 10%, rgba(255,255,255,.04), transparent 40%),
      radial-gradient(circle at 80% 30%, rgba(255,255,255,.03), transparent 45%),
      repeating-linear-gradient(0deg, rgba(255,255,255,.035), rgba(255,255,255,.035) 24px, rgba(255,255,255,.02) 24px, rgba(255,255,255,.02) 48px);
  }
  #board{
    position:relative;
    width:1600px; height:1100px;
    margin:30px;
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.10)), var(--paper);
    border:3px solid var(--line);
    box-shadow:0 8px 30px rgba(0,0,0,.35);
  }

  /* World map stage */
  #mapStage{ position:absolute; inset:0; z-index:1; }
  #mapImg{
    position:absolute; inset:0;
    z-index:1;
    width:100%; height:100%;
    object-fit:contain;
    pointer-events:none;
    opacity:.25;
  }
  #svgHost{ position:absolute; inset:0;z-index: 2; }
  #svgHost svg{ width:100%; height:100%; display:block; }

  /* Territory boundaries (visible even in grey setup view) */
  #svgHost [data-territory-id]{
    stroke: rgba(0,0,0,.85);
    stroke-width: 0.35;
    vector-effect: non-scaling-stroke;
  }

  /* Edges overlay */
  #edges{
    position:absolute; inset:0;
    z-index:3;
    pointer-events:none;
  }
  #edges { background: transparent !important; }
  #edges rect { fill: none !important; }
  .edgeLine{ stroke: rgba(233,227,215,.25); stroke-width: 2; }
  .edgeLine.dim{ stroke: rgba(233,227,215,.12); }
  .edgeLine.strong{ stroke: rgba(233,227,215,.55); stroke-width: 3; }

  
  /* Theatre focus dimming */
  #svgHost .dimmed {
  opacity: 0.12 !important;
}

  .theatre{
    position:absolute; z-index:1;
    display:none;
    border:2px dashed rgba(233,227,215,.25);
    border-radius:10px; overflow:hidden;
  }
  .theatreHeader{
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px;
    border-bottom:1px solid rgba(233,227,215,.18);
    background:rgba(0,0,0,.25);
    font-weight:700; letter-spacing:2px; font-size:13px;
  }
  .theatreBody{position:relative; height:100%;}

  #WE{left:40px;  top:40px;  width:740px; height:480px; background:var(--weTint);}
  #EE{left:820px; top:40px;  width:740px; height:480px; background:var(--eeTint);}
  #NA{left:40px;  top:560px; width:740px; height:480px; background:var(--naTint);}
  #PA{left:820px; top:560px; width:740px; height:480px; background:var(--paTint);}

  /* Territory piece */
  .node{
    position:absolute;
    width:28px; height:28px;
    border-radius:50%;
    border:2px solid #000;
    display:flex; align-items:center; justify-content:center;
    font-size:14px;
    cursor:pointer;
    user-select:none;
    box-shadow:0 2px 8px rgba(0,0,0,.35);
    z-index:3;
    transition: transform .08s ease, box-shadow .08s ease, outline-color .08s ease;
  }
  .node:hover{ transform: translateY(-1px); box-shadow:0 4px 12px rgba(0,0,0,.45); }

  .owner-allies{background:var(--allies); color:#111;}
  .owner-axis{background:var(--axis); color:#111;}
  .owner-ussr{background:var(--ussr); color:#111;}
  .owner-neutral{background:var(--neutral); color:#111;}
  .owner-custom{background:var(--custom); color:#111;}

  /* Fog: greyed but still visible */
  .fog-unknown{ filter: grayscale(1); opacity: .35; }

  /* Selection */
  .selected{ outline: 3px solid rgba(233,227,215,.70); outline-offset: 2px; }
  .adjacent{ outline: 3px solid rgba(233,227,215,.35); outline-offset: 2px; }

  /* Right drawer */
  #panel{
    position:fixed; top:64px; right:0; bottom:0; width:430px;
    background:#171717; border-left:2px solid #444;
    padding:12px; overflow:auto; display:none;
  }

  /* Panel title readability (no clipping) */
  #panel{ padding-top:14px; }
  #panel h2{
    margin-top:6px;
    line-height:1.2;
    white-space:normal;
    word-break:break-word;
  }

  #panel h2{margin:0 0 8px 0; font-size:16px;}
  .meta{color:var(--muted); font-size:12px; margin-bottom:10px;}
  .row{margin:10px 0;}
  .row label{display:block; font-size:12px; color:var(--muted); margin-bottom:4px;}
  .row select, .row textarea, .row input{
    width:100%; background:#222; color:#eee; border:1px solid #555; padding:6px 8px;
    box-sizing:border-box;
  }
  .row textarea{min-height:70px; resize:vertical;}
  .pill{
    display:inline-block; padding:2px 8px; border:1px solid rgba(255,255,255,.15);
    border-radius:999px; font-size:12px; color:#ddd; background:rgba(0,0,0,.25);
    margin-right:6px;
  }
  .btnRow{display:flex; gap:10px; margin-top:10px;}
  .btnRow button{flex:1;}
  .hint{font-size:12px; color:var(--muted); margin-top:10px; line-height:1.4;}
  .linkish{ color:#e9e3d7; text-decoration:underline; cursor:pointer; }
  .linkish:hover{ opacity:.85; }

  .grid2{
    display:grid;
    grid-template-columns: 90px 1fr;
    gap:6px 8px;
    align-items:center;
  }
  .grid2 .tag{ font-size:12px; color:var(--muted); }

  .hr{height:1px;background:rgba(255,255,255,.08); margin:14px 0;}

  .orderCard{
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    padding:8px;
    border-radius:10px;
    margin-top:8px;
  }
  .orderTop{
    display:flex; justify-content:space-between; gap:8px; align-items:center;
    font-size:12px; color:var(--muted);
  }
  .orderMain{ margin-top:6px; font-size:13px; }
  .orderBtns{ display:flex; gap:8px; margin-top:8px; }
  .orderBtns button{ flex:1; }
</style>
</head>

<body>
  <div id="topbar">
    <div class="title">WAR! Campaign — Strategic Board</div>

    <span class="pill" id="turnPill">Turn 1</span>
    <span class="pill" id="phasePill">Strategic</span>

    <span class="smallLabel">Phase</span>
    <select id="phaseSel">
      <option value="Strategic">Strategic</option>
      <option value="Operations">Operations</option>
      <option value="Resolution">Resolution</option>
    </select>

    <button id="advanceBtn">Advance Phase</button>

    <span class="smallLabel">Auto-advance turn</span>
    <select id="autoAdvSel">
      <option value="on" selected>On</option>
      <option value="off">Off</option>
    </select>

    <span class="smallLabel">Mode</span>
    <select id="modeSel">
      <option value="GM">GM</option>
      <option value="PLAYER">Player</option>
    </select>

    <span class="smallLabel">Player Faction</span>
    <select id="playerFactionSel">
      <option value="allies">Allies</option>
      <option value="axis">Axis</option>
      <option value="ussr">USSR</option>
      <option value="custom">Custom</option>
    </select>

    <span class="smallLabel">Adjacency</span>
    <select id="adjSel">
      <option value="off">Off</option>
      <option value="select" selected>On Select</option>
      <option value="always">Always</option>
    </select>


    <label class="smallLabel" style="display:flex;align-items:center;gap:6px;margin-left:6px;">
      <input type="checkbox" id="setupView" checked>
      Setup view
    </label>
    <button onclick="jumpTheatre('WE')">W. Europe</button>
    <button onclick="jumpTheatre('EE')">E. Europe</button>
    <button onclick="jumpTheatre('NA')">N. Africa</button>
    <button onclick="jumpTheatre('PA')">Pacific</button>
    <button onclick="resetWorldView()">World</button>
    <button onclick="exportState()">Export</button>
    <button onclick="importState()">Import</button>
    <button onclick="resetState()">Reset</button>
    
  </div>

  <div id="wrap">
    <div id="board">
      <div id="mapStage">
        <div id="svgHost"></div>
        <svg id="edges"></svg>
      </div>
<div id="WE" class="theatre">
        <div class="theatreHeader"><span>WESTERN EUROPE</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="WE"></div>
      </div>

      <div id="EE" class="theatre">
        <div class="theatreHeader"><span>EASTERN EUROPE</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="EE"></div>
      </div>

      <div id="NA" class="theatre">
        <div class="theatreHeader"><span>NORTH AFRICA</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="NA"></div>
      </div>

      <div id="PA" class="theatre">
        <div class="theatreHeader"><span>PACIFIC</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="PA"></div>
      </div>
    </div>
  </div>

  <aside id="panel">
    <h2 id="pTitle"></h2>
    <div class="meta">
      <span class="pill" id="pTheatre"></span>
      <span class="pill" id="pId"></span>
    </div>

    <!-- Faction HQ quick view -->
    <div class="row">
      <label>Faction HQ (Quick)</label>
      <div class="hint" id="hqQuick"></div>
      <div class="btnRow" id="hqBtns" style="display:none;">
        <button onclick="gmAdjustResources(+1)">+1 Res</button>
        <button onclick="gmAdjustResources(-1)">-1 Res</button>
      </div>
      <div class="hint" style="margin-top:8px;">
        Resource collection happens automatically at start of Strategic: +1 per controlled territory (simple baseline).
      </div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <label>Adjacency</label>
      <div id="adjList" class="hint"></div>
      <div class="hint">Tip: click a neighbour to jump/highlight.</div>
    </div>

    <div class="hr"></div>

    <!-- Movement Helper -->
    <div class="row">
      <label>Movement Helper</label>
      <div class="hint">
        <div><span class="pill">From</span> <span id="mvFrom">—</span></div>
        <div style="margin-top:6px;"><span class="pill">To</span> <span id="mvTo">—</span></div>
      </div>
      <div class="btnRow" style="margin-top:10px;">
        <button onclick="setMoveFromCurrent()">Set as Origin</button>
        <button onclick="trySetMoveToCurrent()">Set as Destination</button>
      </div>
      <div class="btnRow" style="margin-top:10px;">
        <button onclick="logMove()">Log Move</button>
        <button onclick="clearMove()">Clear</button>
      </div>
      <div id="mvHint" class="hint"></div>
      <div id="mvOptions" class="hint" style="margin-top:10px;"></div>
    </div>

    <div class="hr"></div>

    <!-- Orders -->
    <div class="row">
      <label>Orders (Operations Phase)</label>
      <div class="hint" id="ordersHint"></div>

      <div class="row">
        <label>General Name</label>
        <input id="orderGeneral" placeholder="e.g. Gen. Montgomery" />
      </div>

      <div class="row">
        <label>Order Type</label>
        <select id="orderType">
          <option value="Move">Move</option>
          <option value="Attack">Attack</option>
          <option value="Recon">Recon</option>
          <option value="Withdraw">Withdraw</option>
          <option value="Bombard">Bombard</option>
          <option value="Hold">Hold</option>
        </select>
      </div>

      <div class="row">
        <label>From (use current territory or pick)</label>
        <select id="orderFrom"></select>
      </div>

      <div class="row">
        <label>To (optional; for Move/Attack/Recon/Bombard/Withdraw)</label>
        <select id="orderTo"></select>
        <div class="hint" style="margin-top:8px;">Move/Attack/etc must be adjacent. Hold ignores To.</div>
      </div>

      <div class="row">
        <label>Condition (optional; 1 binary condition max)</label>
        <input id="orderCond" placeholder='e.g. "If enemy present, Withdraw; else Move"' />
      </div>

      <div class="row">
        <label>Notes</label>
        <input id="orderNotes" placeholder="Any extra detail for GM." />
      </div>

      <div class="btnRow">
        <button onclick="createOrder()">Add Order</button>
        <button onclick="closePanel()">Close</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        Player orders are hidden from other factions until Resolution. After Ops ends, orders lock.
      </div>

      <div id="ordersList"></div>
    </div>

    <div class="hr"></div>

    <div id="playerInfo" class="row" style="display:none;">
      <div class="hint">Player view: Unknown territories stay visible but greyed.</div>
    </div>

    <div id="gmControls" style="display:none;">
      <div class="row">
        <label>Owner</label>
        <select id="ownerSel">
          <option value="neutral">Neutral</option>
          <option value="allies">Allies</option>
          <option value="axis">Axis</option>
          <option value="ussr">USSR</option>
          <option value="custom">Custom</option>
        </select>
      </div>

      <div class="row">
        <label>Visibility (per faction)</label>
        <div class="grid2">
          <div class="tag">Allies</div>
          <select id="visAllies"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
          <div class="tag">Axis</div>
          <select id="visAxis"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
          <div class="tag">USSR</div>
          <select id="visUSSR"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
          <div class="tag">Custom</div>
          <select id="visCustom"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
        </div>
      </div>

      <div class="row">
        <label>GM Notes</label>
        <textarea id="notes"></textarea>
      </div>

      <div class="btnRow">
        <button onclick="saveTerritory()">Save Territory</button>
        <button onclick="closePanel()">Close</button>
      </div>
    </div>

    <div class="hint" style="margin-top:14px;">
      Icons: ★ Allies, ✚ Axis, ☭ USSR, ⚑ Custom, ● Neutral
    </div>
  </aside>

<script>

/** Fixed positions (15 slots) used in every theatre panel */
const POS15 = [
  [140,110],[230,90],[330,95],[440,90],
  [120,190],[230,185],[340,190],[460,185],
  [140,270],[245,290],[350,280],[455,290],
  [200,360],[360,360],
  [280,410]
];

const THEATRE_NAME = {WE:"Western Europe", EE:"Eastern Europe", NA:"North Africa", PA:"Pacific"};
const OWNER_ICON = {allies:"★", axis:"✚", ussr:"☭", neutral:"●", custom:"⚑"};
const HUBS = new Set(["WE-02","WE-08","WE-09","NA-05","NA-15","PA-02","PA-07","PA-15"]);
const CHOKES = new Map([
  ["WE-14","Gibraltar"],
  ["NA-15","Suez"]
]);
const STORAGE_KEY = "war_board_state_v3";

/** Territories loaded from theatres_all.json */
let TERRS = [];
let byId = new Map();

async function loadAppTheatres(){
  // Try common locations (repo layouts differ). First hit wins.
  const candidates = [
    'theatres_all.json',
  ];
  let lastErr = null;
  for(const url of candidates){
    try{
      const res = await fetch(url, { cache: 'no-store' });
      if(res.ok) return await res.json();
      lastErr = new Error(`HTTP ${res.status} for ${url}`);
    }catch(e){
      lastErr = e;
    }
  }
  throw new Error(`Failed to load theatres_all.json from any known path. Last error: ${lastErr}`);
}
async function loadWorldSvg(){
  const res = await fetch('assets/mapchart_world.svg', { cache:'no-store' });
  if(!res.ok) throw new Error(`Failed to load map SVG: ${res.status}`);
  const svgText = await res.text();
  document.getElementById('svgHost').innerHTML = svgText;

  // ensure the injected svg is findable
  const svg = document.querySelector('#svgHost svg');
  
  if(!svg) throw new Error("SVG did not load correctly into #svgHost.");

  svg.setAttribute('preserveAspectRatio','xMidYMid meet');
  return svg;
}
let baseViewBox = null;

function getSvg() {
  return document.querySelector('#svgHost svg');
}

function captureBaseViewBox() {
  const svg = getSvg();
  if (!svg) return;

  // Ensure a viewBox exists
  if (!svg.hasAttribute('viewBox')) {
    const b = svg.getBBox();
    svg.setAttribute('viewBox', `${b.x} ${b.y} ${b.width} ${b.height}`);
  }
  baseViewBox = svg.getAttribute('viewBox');
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
}

function resetWorldView() {
  const svg = getSvg();
  if (!svg || !baseViewBox) return;

  // Reset zoom
  svg.setAttribute('viewBox', baseViewBox);

  // Undim everything
  svg.querySelectorAll('[data-territory-id]').forEach(el => el.classList.remove('dimmed'));
}

// Returns array of DOM elements belonging to theatre territories
function theatreElements(theatreId) {
  const svg = getSvg();
  if (!svg) return [];

  const ids = TERRS
    .filter(t => t.theatreKey === theatreId)
    .map(t => t.id);

  const els = [];
  for (const tid of ids) {
    svg.querySelectorAll(`[data-territory-id="${tid}"]`).forEach(el => els.push(el));
  }
  return els;
}

function focusTheatre(theatreId) {
  const svg = getSvg();
  if (!svg) return;

  // Dim everything first
  svg.querySelectorAll('[data-territory-id]').forEach(el => el.classList.add('dimmed'));

  // Undim this theatre
  const els = theatreElements(theatreId);
  els.forEach(el => el.classList.remove('dimmed'));
}

function zoomToElements(els, padFrac = 0.12) {
  const svg = getSvg();
  if (!svg || !els.length) return;

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const el of els) {
    const b = el.getBBox();
    minX = Math.min(minX, b.x);
    minY = Math.min(minY, b.y);
    maxX = Math.max(maxX, b.x + b.width);
    maxY = Math.max(maxY, b.y + b.height);
  }

  const w = maxX - minX;
  const h = maxY - minY;
  const padX = w * padFrac;
  const padY = h * padFrac;

  const x = minX - padX;
  const y = minY - padY;
  const vw = w + padX * 2;
  const vh = h + padY * 2;

  svg.setAttribute('viewBox', `${x} ${y} ${vw} ${vh}`);
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
}

// Main: theatre button handler
function jumpTheatre(theatreId) {
  const els = theatreElements(theatreId);
  if (!els.length) {
    console.warn('No SVG elements found for theatre', theatreId);
    return;
  }
  focusTheatre(theatreId);
  zoomToElements(els, 0.12);
}

// Create one clickable "territory group" for all its shapeRefs
function bindTerritoriesToSvg(){
  const svg = document.querySelector('#svgHost svg');
  if(!svg) return;

  const shapeToPath = new Map();
  svg.querySelectorAll('path[id], polygon[id]').forEach(p => shapeToPath.set(p.id, p));

  // Expand refs like "France_FR_2-9" into ["France_FR_2",...,"France_FR_9"]
  function expandShapeRef(ref){
    const m = ref.match(/^(.*_)(\d+)-(\d+)$/);
    if(!m) return [ref];
    const prefix = m[1];
    const a = parseInt(m[2], 10);
    const b = parseInt(m[3], 10);
    if(!Number.isFinite(a) || !Number.isFinite(b)) return [ref];
    const start = Math.min(a,b), end = Math.max(a,b);
    const out = [];
    for(let n=start; n<=end; n++) out.push(prefix + n);
    return out;
  }

  for(const t of TERRS){
    const refs = t.shapeRefs || [];
    for(const raw of refs){
      for(const ref of expandShapeRef(raw)){
        const path = shapeToPath.get(ref);
        if(!path){
          console.warn('Missing SVG path for shapeRef:', ref, 'territory:', t.id);
          continue;
        }
        
        // store original MapChart fill so we can revert for neutral owner
        if(!path.dataset.baseFill){
          const base = path.getAttribute('fill') || getComputedStyle(path).fill;
          path.dataset.baseFill = base;
        }
path.setAttribute('data-territory-id', t.id);
        path.style.cursor = 'pointer';

        // Tooltip (only add once)
        if(!path.querySelector('title')){
          const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
          title.textContent = `${t.id} — ${t.name}`;
          path.appendChild(title);
        }

        path.addEventListener('click', (e) => {
          e.stopPropagation();
          openPanel(t.id);
        });
      }
    }
  }
}

// Style fills based on owner + fog, and compute centers for adjacency drawing
function rerenderSvgFills() {
  const svg = document.querySelector('#svgHost svg');
  if (!svg) return;

  const setup = document.getElementById('setupView')?.checked;
  const root = getComputedStyle(document.documentElement);
  const neutralFill = root.getPropertyValue('--neutral').trim() || '#d1dbdd';

  svg.querySelectorAll('[data-territory-id]').forEach(el => {
    const tid = el.dataset.territoryId;
    const st = state?.[tid];

    // Always visible; borders handled via CSS
    el.style.opacity = '1';
    el.classList.remove('fog-unknown');

    if (setup) {
      // Hybrid setup view: all territories grey, but borders show the shapes.
      el.style.fill = neutralFill;
      return;
    }

    // Normal view: colour by owner
    const owner = st?.owner || 'neutral';
    el.style.fill = ownerToColor(owner);

    // Fog (only in Player view, optional)
    if (modeSel.value === "PLAYER") {
      const faction = playerFactionSel.value;
      const v = st?.vis?.[faction] || "Unknown";
      if (v === "Unknown") el.classList.add('fog-unknown');
    }
  });
}


// Get centroid from combined bboxes of all SVG paths in a territory
function territoryCenterOnSvg(territoryId){
  const paths = Array.from(document.querySelectorAll(`#svgHost [data-territory-id="${territoryId}"]`));
  if(!paths.length) return null;

  // union bbox
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const p of paths){
    const b = p.getBBox();
    minX = Math.min(minX, b.x);
    minY = Math.min(minY, b.y);
    maxX = Math.max(maxX, b.x + b.width);
    maxY = Math.max(maxY, b.y + b.height);
  }

  // Convert SVG coordinates into screen coords:
  const svg = document.querySelector('#svgHost svg');
  const pt = svg.createSVGPoint();
  pt.x = (minX + maxX) / 2;
  pt.y = (minY + maxY) / 2;

  const ctm = svg.getScreenCTM();
  if(!ctm) return null;
  const sp = pt.matrixTransform(ctm);

  // Convert screen -> board local coords (so your edges SVG can draw correctly)
  const boardRect = board.getBoundingClientRect();
  return { x: sp.x - boardRect.left, y: sp.y - boardRect.top };
}

function buildTerrsFromData(data){
  const out = [];
  for(const theatre of data.theatres){
    for(const terr of theatre.territories){
      const adjRaw = theatre.adjacency?.[terr.id];

      // Support adjacency formats:
      //  - { land:[...], sea:[...] }
      //  - [ ... ] (treated as land)
      let land = [], sea = [];
      if(Array.isArray(adjRaw)){
        land = adjRaw;
      } else if(adjRaw && typeof adjRaw === 'object'){
        land = adjRaw.land || [];
        sea  = adjRaw.sea  || [];
      }
      const combined = Array.from(new Set([...land, ...sea]));
      const adj = { land, sea };
      out.push({
        id: terr.id,
        name: terr.name,
        theatreKey: theatre.theatreId,
        shapeRefs: terr.shapeRefs || [],
        adj: combined,
        adjLand: adj.land || [],
        adjSea: adj.sea || []
      });
    }
  }
  out.sort((a,b)=> a.id.localeCompare(b.id));
  return out;
}


function ensureAdjacencyIfMissing(){
  // If ANY territory already has adjacency, assume real adjacency exists
  const hasAny = TERRS.some(t => (t.adj && t.adj.length));
  if(hasAny) return;

  console.warn("No adjacency data found in theatres_all.json; using fallback adjacency (simple theatre chains + a few links).");

  // Group by theatre
  const groups = {};
  for(const t of TERRS){
    (groups[t.theatreKey] ||= []).push(t);
  }
  // Chain by sorted id within each theatre: A<->B<->C...
  for(const key of Object.keys(groups)){
    const arr = groups[key].slice().sort((a,b)=>a.id.localeCompare(b.id));
    for(let i=0;i<arr.length;i++){
      const here = arr[i];
      const neigh = new Set(here.adj || []);
      if(i>0) neigh.add(arr[i-1].id);
      if(i<arr.length-1) neigh.add(arr[i+1].id);
      here.adj = Array.from(neigh);
      here.adjLand = Array.from(neigh); // treat as land for now
      here.adjSea = [];
    }
  }

  // A few WW2-flavoured inter-theatre links (treated as sea lanes)
  function link(a,b){
    const A = byId.get(a), B = byId.get(b);
    if(!A || !B) return;
    if(!A.adj.includes(b)) A.adj.push(b);
    if(!B.adj.includes(a)) B.adj.push(a);
    if(!A.adjSea.includes(b)) A.adjSea.push(b);
    if(!B.adjSea.includes(a)) B.adjSea.push(a);
  }
  // Gibraltar / Morocco
  link("WE-14","NA-01");
  // Sicily <-> Tunis / Tripoli
  link("WE-11","NA-05");
  link("WE-11","NA-06");
  // Suez lane toward Malaya (strategic route)
  link("NA-15","PA-07");
}

const board = document.getElementById("board");
const edgesSvg = document.getElementById("edges");

const modeSel = document.getElementById("modeSel");
const playerFactionSel = document.getElementById("playerFactionSel");
const adjSel = document.getElementById("adjSel");

const phaseSel = document.getElementById("phaseSel");
const advanceBtn = document.getElementById("advanceBtn");
const autoAdvSel = document.getElementById("autoAdvSel");

const turnPill = document.getElementById("turnPill");
const phasePill = document.getElementById("phasePill");

let state = null;
let currentId = null;

/* Movement helper state */
let moveFrom = null;
let moveTo = null;

modeSel.addEventListener("change", () => {
  applyMode();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshMoveUI();
  refreshHQQuick();
  refreshOrdersUI();
  refreshPhaseUI();
});

playerFactionSel.addEventListener("change", () => {
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshMoveUI();
  refreshHQQuick();
  refreshOrdersUI();
});

adjSel.addEventListener("change", () => redrawEdges());


const setupViewEl = document.getElementById("setupView");
setupViewEl?.addEventListener("change", () => {
  rerenderSvgFills();
  redrawEdges();
});


phaseSel.addEventListener("change", () => {
  // Players can't change phase
  if(modeSel.value !== "GM"){
    refreshPhaseUI();
    return;
  }
  setPhase(phaseSel.value, {manual:true});
});

autoAdvSel.addEventListener("change", () => {
  state._meta.autoAdvanceTurn = (autoAdvSel.value === "on");
  saveState();
});

advanceBtn.addEventListener("click", () => {
  if(modeSel.value !== "GM") return;
  advancePhase();
});

function scrollToTheatre(key){
  document.getElementById(key)?.scrollIntoView({behavior:"smooth", block:"start", inline:"nearest"});
}
function defaultMeta(){
  return {
    turn: 1,
    phase: "Strategic",
    autoAdvanceTurn: true,
    moveLog: [],
    orders: {},   // orders[turn][faction] = []
    factions: {
      allies:{resources:0},
      axis:{resources:0},
      ussr:{resources:0},
      custom:{resources:0}
    }
  };
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      // Territory backfill
      for(const t of TERRS){
        if(!parsed[t.id]) parsed[t.id] = {};
        parsed[t.id].owner = parsed[t.id].owner || "neutral";
        parsed[t.id].vis = parsed[t.id].vis || {allies:"Known", axis:"Known", ussr:"Known", custom:"Known"};
        parsed[t.id].notes = parsed[t.id].notes || "";
      }
      // Meta backfill
      parsed._meta = parsed._meta || defaultMeta();
      parsed._meta.turn = typeof parsed._meta.turn === "number" ? parsed._meta.turn : 1;
      parsed._meta.phase = parsed._meta.phase || "Strategic";
      parsed._meta.autoAdvanceTurn = (parsed._meta.autoAdvanceTurn !== false);
      parsed._meta.moveLog = Array.isArray(parsed._meta.moveLog) ? parsed._meta.moveLog : [];
      parsed._meta.orders = parsed._meta.orders || {};
      parsed._meta.factions = parsed._meta.factions || defaultMeta().factions;
      for(const f of ["allies","axis","ussr","custom"]){
        if(!parsed._meta.factions[f]) parsed._meta.factions[f] = {resources:0};
        if(typeof parsed._meta.factions[f].resources !== "number") parsed._meta.factions[f].resources = 0;
      }
      return parsed;
    }
  }catch(e){}
  const s = {};
  for(const t of TERRS){
    s[t.id] = {
      owner:"neutral",
      vis:{allies:"Known", axis:"Known", ussr:"Known", custom:"Known"},
      notes:""
    };
  }
  s._meta = defaultMeta();
  return s;
}

function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function resetState(){
  if(!confirm("Reset all campaign state on this device?")) return;
  localStorage.removeItem(STORAGE_KEY);
  state = loadState();
  closePanel();
  clearMove();
  renderAll();
}

function exportState(){
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "war_state.json";
  a.click();
  URL.revokeObjectURL(a.href);
}

function importState(){
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "application/json";
  input.onchange = () => {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const parsed = JSON.parse(reader.result);
        const fresh = loadState();
        for(const k of Object.keys(parsed)) fresh[k] = parsed[k];
        state = fresh;
        saveState();
        closePanel();
        renderAll();
      }catch(e){
        alert("Invalid JSON.");
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

/* -------------------------
   Turn + Phase
-------------------------- */
function refreshPhaseUI(){
  const m = state._meta;
  turnPill.textContent = `Turn ${m.turn}`;
  phasePill.textContent = m.phase;
  phaseSel.value = m.phase;
  autoAdvSel.value = m.autoAdvanceTurn ? "on" : "off";

  // Only GM can change phase selector
  phaseSel.disabled = (modeSel.value !== "GM");
  advanceBtn.disabled = (modeSel.value !== "GM");

  // If Ops ended, lock orders (safety)
  if(m.phase !== "Operations"){
    lockOrdersForTurn(m.turn);
  }
}

function setPhase(newPhase, {manual=false}={}){
  const old = state._meta.phase;
  state._meta.phase = newPhase;

  // Auto resource collection at START of Strategic
  if(old !== "Strategic" && newPhase === "Strategic"){
    autoCollectResources();
  }

  // Lock orders when leaving Operations
  if(old === "Operations" && newPhase !== "Operations"){
    lockOrdersForTurn(state._meta.turn);
  }

  saveState();
  refreshPhaseUI();
  refreshOrdersUI();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
}

function advancePhase(){
  const p = state._meta.phase;
  if(p === "Strategic") setPhase("Operations", {manual:true});
  else if(p === "Operations") setPhase("Resolution", {manual:true});
  else {
    // Resolution -> Strategic (next turn if auto)
    if(state._meta.autoAdvanceTurn){
      state._meta.turn += 1;
    }
    setPhase("Strategic", {manual:true});
  }
}

function lockOrdersForTurn(turn){
  const bucket = (state._meta.orders && state._meta.orders[turn]) ? state._meta.orders[turn] : null;
  if(!bucket) return;
  for(const f of Object.keys(bucket)){
    for(const o of bucket[f]){
      o.status = "locked";
    }
  }
  saveState();
}

/* Simple baseline: +1 resource per controlled territory */
function autoCollectResources(){
  const counts = {allies:0, axis:0, ussr:0, custom:0};
  for(const t of TERRS){
    const owner = state[t.id].owner;
    if(counts[owner] !== undefined) counts[owner] += 1;
  }
  for(const f of ["allies","axis","ussr","custom"]){
    state._meta.factions[f].resources += counts[f];
  }
  saveState();
}

/* GM quick adjust (panel faction = either playerFaction in player mode, or current selector in GM) */
function gmAdjustResources(delta){
  if(modeSel.value !== "GM") return;
  const f = playerFactionSel.value;
  state._meta.factions[f].resources = Math.max(0, state._meta.factions[f].resources + delta);
  saveState();
  refreshHQQuick();
}

/* -------------------------
   Ownership + Fog
-------------------------- */
function applyMode(){
  const mode = modeSel.value;
  document.getElementById("gmControls").style.display = (mode==="GM") ? "block" : "none";
  document.getElementById("playerInfo").style.display = (mode==="PLAYER") ? "block" : "none";
  document.getElementById("hqBtns").style.display = (mode==="GM") ? "flex" : "none";
}

function nodeClassFor(owner){ return `node owner-${owner}`; }

function rerenderNodeFog(){
  const mode = modeSel.value;
  const faction = playerFactionSel.value;
  document.querySelectorAll(".node").forEach(el => {
    const tid = el.dataset.id;
    const st = state[tid];
    el.classList.remove("fog-unknown");
    if(mode === "PLAYER"){
      const v = (st && st.vis && st.vis[faction]) ? st.vis[faction] : "Unknown";
      if(v === "Unknown") el.classList.add("fog-unknown");
    }
  });
  if(currentId) refreshPanel(currentId);
}

/* -------------------------
   Render Map
-------------------------- */
function renderAll(){
  document.querySelectorAll(".theatreBody").forEach(b => b.innerHTML = "");
  clearEdges();
  clearHighlights();
  populateOrderDropdowns();

  const byTheatre = {WE:[], EE:[], NA:[], PA:[]};
  for(const t of TERRS) byTheatre[t.theatreKey].push(t);

  for(const key of Object.keys(byTheatre)){
    const body = document.querySelector(`.theatreBody[data-theatre="${key}"]`);
    const list = byTheatre[key];
    list.sort((a,b)=> a.id.localeCompare(b.id));

    list.forEach((t, idx) => {
const [x,y] = POS15[idx] || POS15[POS15.length-1];
      const st = state[t.id];
      const el = document.createElement("div");
      el.className = nodeClassFor(st.owner);
      el.style.left = x + "px";
      el.style.top = y + "px";
      el.textContent = OWNER_ICON[st.owner] || "●";
      el.dataset.id = t.id;
      el.dataset.theatre = key;
      el.title = `${t.id} — ${t.name}`;
      el.addEventListener("click", () => openPanel(t.id));
      body.appendChild(el);
    });
  }

  applyMode();
  refreshPhaseUI();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshHQQuick();
  refreshMoveUI();
  refreshOrdersUI();
}

function clearHighlights(){
  document.querySelectorAll(".node").forEach(n => {
    n.classList.remove("selected");
    n.classList.remove("adjacent");
  });
}

/* --- Adjacency edges --- */
function clearEdges(){
  while(edgesSvg.firstChild) edgesSvg.removeChild(edgesSvg.firstChild);
}
function nodeCenter(id){
   return territoryCenterOnSvg(id);
}

function drawMarker(tid, kind){
  const p = nodeCenter(tid);
  if(!p) return;

  const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx", p.x);
  c.setAttribute("cy", p.y);
  c.setAttribute("r", kind === "hub" ? "6" : "5");
  c.setAttribute("fill", kind === "hub" ? "rgba(233,227,215,.85)" : "rgba(255,220,120,.85)");
  c.setAttribute("stroke", "rgba(0,0,0,.85)");
  c.setAttribute("stroke-width", "1");
  c.setAttribute("class", kind === "hub" ? "hubMarker" : "chokeMarker");
  edgesSvg.appendChild(c);
}

function drawLine(aId, bId, cls){
  const a = nodeCenter(aId), b = nodeCenter(bId);
  if(!a || !b) return;
  const line = document.createElementNS("http://www.w3.org/2000/svg","line");
  line.setAttribute("x1", a.x); line.setAttribute("y1", a.y);
  line.setAttribute("x2", b.x); line.setAttribute("y2", b.y);
  line.setAttribute("class", cls);
  edgesSvg.appendChild(line);
}
function redrawEdges(){
  edgesSvg.setAttribute("width", board.clientWidth);
  edgesSvg.setAttribute("height", board.clientHeight);
  edgesSvg.setAttribute("viewBox", `0 0 ${board.clientWidth} ${board.clientHeight}`);

  const mode = adjSel.value;
  clearEdges();

  // If anything inserts a background rect, kill it
  edgesSvg.querySelectorAll("rect").forEach(r => r.setAttribute("fill", "none"));

  // Always show key markers (hubs + chokepoints)
  HUBS.forEach(id => drawMarker(id, "hub"));
  for(const [id] of CHOKES) drawMarker(id, "choke");

  if(mode === "off") return;

  if(mode === "always"){
    const seen = new Set();
    for(const t of TERRS){
      for(const n of t.adj){
        const key = [t.id, n].sort().join("|");
        if(seen.has(key)) continue;
        seen.add(key);
        drawLine(t.id, n, "edgeLine");
      }
    }
    return;
  }
  if(currentId) highlightAdjacency(currentId);
}
function highlightAdjacency(id){
  clearEdges();
  clearHighlights();
  const t = byId.get(id);
  if(!t) return;

  const selectedEl = document.querySelector(`.node[data-id="${id}"]`);
  if(selectedEl) selectedEl.classList.add("selected");

  const mode = modeSel.value;
  const faction = playerFactionSel.value;

  for(const n of t.adj){
    const nEl = document.querySelector(`.node[data-id="${n}"]`);
    if(nEl) nEl.classList.add("adjacent");

    let cls = "edgeLine strong";
    if(mode === "PLAYER"){
      const st = state[n];
      const vis = (st && st.vis && st.vis[faction]) ? st.vis[faction] : "Unknown";
      if(vis === "Unknown") cls = "edgeLine dim";
    }
    drawLine(id, n, cls);
  }
}

/* -------------------------
   Panel
-------------------------- */
function openPanel(id){
  currentId = id;
  refreshPanel(id);
  document.getElementById("panel").style.display = "block";

  // Prefill order FROM to selected territory
  document.getElementById("orderFrom").value = id;

  if(adjSel.value === "select") highlightAdjacency(id);
  else{
    clearHighlights();
    const el = document.querySelector(`.node[data-id="${id}"]`);
    if(el) el.classList.add("selected");
  }

  refreshHQQuick();
  refreshMoveUI();
  refreshOrdersUI();
}

function closePanel(){
  currentId = null;
  document.getElementById("panel").style.display = "none";
  clearHighlights();
  redrawEdges();
}

function refreshPanel(id){
  const t = byId.get(id);
  if(!t) return;
  const st = state[id];

  document.getElementById("pTitle").textContent = t.name;
  document.getElementById("pTheatre").textContent = THEATRE_NAME[t.theatreKey];
  document.getElementById("pId").textContent = t.id;

  // adjacency list
 const adjList = document.getElementById("adjList");
const land = (t.adjLand || []);
const sea  = (t.adjSea || []);

if(!land.length && !sea.length){
  adjList.textContent = "None";
} else {
  adjList.innerHTML = `
    <div><span class="pill">Land</span> ${land.map(nid => linkSpan(nid)).join(" • ") || "—"}</div>
    <div style="margin-top:6px;"><span class="pill">Sea</span> ${sea.map(nid => linkSpan(nid)).join(" • ") || "—"}</div>
  `;

  // attach click handlers
  [...land, ...sea].forEach(nid => {
    const el = adjList.querySelector(`[data-jump="${nid}"]`);
    if(el){
      el.onclick = () => {
        const nt = byId.get(nid);
        if(!nt) return;
        jumpTheatre(nt.theatreId || nt.theatreKey);
        setTimeout(() => openPanel(nid), 250);
      };
    }
  });
}

function linkSpan(nid){
  const nt = byId.get(nid);
  const label = nt ? `${nid} — ${nt.name}` : nid;
  return `<span class="linkish" data-jump="${nid}">${escapeHtml(label)}</span>`;
}


  // GM fields
  if(modeSel.value === "GM"){
    document.getElementById("ownerSel").value = st.owner;
    document.getElementById("visAllies").value = st.vis.allies || "Known";
    document.getElementById("visAxis").value = st.vis.axis || "Known";
    document.getElementById("visUSSR").value = st.vis.ussr || "Known";
    document.getElementById("visCustom").value = st.vis.custom || "Known";
    document.getElementById("notes").value = st.notes || "";
  }
}

function saveTerritory(){
  if(!currentId) return;
  const st = state[currentId];
  st.owner = document.getElementById("ownerSel").value;
  st.vis = {
    allies: document.getElementById("visAllies").value,
    axis: document.getElementById("visAxis").value,
    ussr: document.getElementById("visUSSR").value,
    custom: document.getElementById("visCustom").value
  };
  st.notes = document.getElementById("notes").value || "";
  saveState();

  const node = document.querySelector(`.node[data-id="${currentId}"]`);
  if(node){
    node.className = nodeClassFor(st.owner);
    node.textContent = OWNER_ICON[st.owner] || "●";
  }
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshHQQuick();
}

/* -------------------------
   HQ Quick
-------------------------- */
function refreshHQQuick(){
  const f = playerFactionSel.value;
  const res = state._meta.factions[f].resources;

  let ctrl = 0;
  for(const t of TERRS){
    if(state[t.id].owner === f) ctrl++;
  }

  const phase = state._meta.phase;
  const turn = state._meta.turn;
  const who = (modeSel.value === "GM") ? "GM view" : "Player view";

  document.getElementById("hqQuick").innerHTML =
    `Faction: <b>${f.toUpperCase()}</b> • Resources: <b>${res}</b> • Controlled: <b>${ctrl}</b><br>` +
    `Turn: <b>${turn}</b> • Phase: <b>${phase}</b> • ${who}`;
}

/* -------------------------
   Movement Helper
-------------------------- */
function setMoveFromCurrent(){
  if(!currentId) return;
  moveFrom = currentId;
  if(moveTo && !isAdjacent(moveFrom, moveTo)) moveTo = null;
  refreshMoveUI();
  if(adjSel.value === "select") highlightAdjacency(moveFrom);
}
function trySetMoveToCurrent(){
  if(!currentId) return;
  if(!moveFrom){ setMoveFromCurrent(); return; }
  if(currentId === moveFrom){ moveTo = null; refreshMoveUI(); return; }
  if(isAdjacent(moveFrom, currentId)){
    moveTo = currentId;
    setMoveHint("");
  } else {
    setMoveHint(`Not adjacent: ${moveFrom} → ${currentId}. Choose a highlighted neighbour.`);
    moveTo = null;
  }
  refreshMoveUI();
}
function isAdjacent(a, b){
  const ta = byId.get(a);
  return ta && (ta.adj || []).includes(b);
}
function clearMove(){
  moveFrom = null; moveTo = null;
  setMoveHint("");
  refreshMoveUI();
}
function setMoveHint(msg){ document.getElementById("mvHint").textContent = msg || ""; }

function refreshMoveUI(){
  const fromT = moveFrom ? byId.get(moveFrom) : null;
  const toT = moveTo ? byId.get(moveTo) : null;

  document.getElementById("mvFrom").textContent = fromT ? `${moveFrom} — ${fromT.name}` : "—";
  document.getElementById("mvTo").textContent = toT ? `${moveTo} — ${toT.name}` : "—";

  const optionsEl = document.getElementById("mvOptions");
  optionsEl.innerHTML = "";

  if(moveFrom){
    const ta = byId.get(moveFrom);
    const title = document.createElement("div");
    title.className = "hint";
    title.textContent = "Valid destinations:";
    optionsEl.appendChild(title);

    const list = document.createElement("div");
    (ta.adj || []).forEach((nid, i) => {
      const nt = byId.get(nid);
      const span = document.createElement("span");
      span.className = "linkish";
      span.textContent = `${nid} — ${nt.name}`;
      span.onclick = () => {
        moveTo = nid;
        jumpTheatre(nt.theatreId || nt.theatreKey);
        setTimeout(() => openPanel(nid), 250);
        refreshMoveUI();
      };
      list.appendChild(span);
      if(i < ta.adj.length-1) list.appendChild(document.createTextNode(" • "));
    });
    optionsEl.appendChild(list);

    if(moveTo && !isAdjacent(moveFrom, moveTo)){
      moveTo = null;
      setMoveHint("Destination cleared (not adjacent).");
    }
  } else {
    optionsEl.textContent = "Set an origin to see valid destinations.";
  }
}

function logMove(){
  if(!moveFrom || !moveTo){ setMoveHint("Set both Origin and Destination first."); return; }
  if(!isAdjacent(moveFrom, moveTo)){ setMoveHint("Invalid move (not adjacent)."); return; }

  if(modeSel.value !== "GM"){
    setMoveHint("Player mode: move planned (not logged). Switch to GM to log.");
    return;
  }

  const entry = { turn: state._meta.turn, from: moveFrom, to: moveTo, ts: new Date().toISOString() };
  state._meta.moveLog.push(entry);
  saveState();
  setMoveHint(`Logged: Turn ${entry.turn} — ${entry.from} → ${entry.to}`);
}

/* -------------------------
   Orders System
-------------------------- */
function getOrdersBucket(turn){
  if(!state._meta.orders) state._meta.orders = {};
  if(!state._meta.orders[turn]){
    state._meta.orders[turn] = {allies:[], axis:[], ussr:[], custom:[]};
  } else {
    // backfill factions
    for(const f of ["allies","axis","ussr","custom"]){
      if(!state._meta.orders[turn][f]) state._meta.orders[turn][f] = [];
    }
  }
  return state._meta.orders[turn];
}

function populateOrderDropdowns(){
  const fromSel = document.getElementById("orderFrom");
  const toSel = document.getElementById("orderTo");
  const ids = TERRS.map(t => t.id).sort();

  fromSel.innerHTML = "";
  toSel.innerHTML = "";

  for(const id of ids){
    const t = byId.get(id);
    const opt1 = document.createElement("option");
    opt1.value = id;
    opt1.textContent = `${id} — ${t.name}`;
    fromSel.appendChild(opt1);

    const opt2 = document.createElement("option");
    opt2.value = id;
    opt2.textContent = `${id} — ${t.name}`;
    toSel.appendChild(opt2);
  }
}

function refreshOrdersUI(){
  const turn = state._meta.turn;
  const phase = state._meta.phase;
  const mode = modeSel.value;
  const pf = playerFactionSel.value;

  const hint = document.getElementById("ordersHint");
  const canSubmit = (phase === "Operations");
  if(phase !== "Operations"){
    hint.textContent = `Current phase is ${phase}. Orders are submitted in Operations. In Resolution, orders are revealed.`;
  } else {
    hint.textContent = `Operations Phase: submit secret orders. Orders lock when Ops ends.`;
  }

  // Disable add order UI if not Ops and not GM
  const disableInputs = (!canSubmit && mode !== "GM");
  for(const id of ["orderGeneral","orderType","orderFrom","orderTo","orderCond","orderNotes"]){
    document.getElementById(id).disabled = disableInputs;
  }

  renderOrdersList();
}

function createOrder(){
  const turn = state._meta.turn;
  const phase = state._meta.phase;
  const mode = modeSel.value;
  const pf = playerFactionSel.value;

  if(phase !== "Operations" && mode !== "GM"){
    alert("Orders can only be added in Operations Phase (unless GM).");
    return;
  }

  const general = document.getElementById("orderGeneral").value.trim() || "Unnamed General";
  const type = document.getElementById("orderType").value;
  const from = document.getElementById("orderFrom").value;
  const to = document.getElementById("orderTo").value;
  const cond = document.getElementById("orderCond").value.trim();
  const notes = document.getElementById("orderNotes").value.trim();

  // adjacency validation for relevant types
  const needsTo = !["Hold"].includes(type);
  if(needsTo){
    if(!isAdjacent(from, to)){
      alert(`Invalid: ${type} requires an adjacent target. ${from} → ${to} is not adjacent.`);
      return;
    }
  }

  // binary condition best-effort: just warn if looks like multiple conditions
  const bad = /(\bif\b.*\bif\b)|(\bunless\b.*\bunless\b)/i.test(cond);
  if(cond && bad){
    if(!confirm("Condition looks complex (multiple conditions). Keep it anyway?")) return;
  }

  const bucket = getOrdersBucket(turn);
  const order = {
    id: cryptoId(),
    turn,
    faction: pf,
    general,
    type,
    from,
    to: needsTo ? to : null,
    condition: cond || null,
    notes: notes || null,
    status: (phase === "Operations") ? "draft" : "locked",
    submittedAt: new Date().toISOString()
  };
  bucket[pf].push(order);
  saveState();
  renderOrdersList();
}

function canViewOrder(o){
  const mode = modeSel.value;
  const pf = playerFactionSel.value;
  const phase = state._meta.phase;

  if(mode === "GM") return true;

  // Player sees own faction orders always (even in Operations)
  if(o.faction === pf) return true;

  // Enemy orders visible only in Resolution (and later)
  if(phase === "Resolution") return true;

  return false;
}

function canEditOrder(o){
  const mode = modeSel.value;
  const pf = playerFactionSel.value;
  const phase = state._meta.phase;

  if(mode === "GM") return true;
  if(o.faction !== pf) return false;
  if(phase !== "Operations") return false;
  if(o.status !== "draft") return false;
  return true;
}

function renderOrdersList(){
  const list = document.getElementById("ordersList");
  list.innerHTML = "";

  const turn = state._meta.turn;
  const bucket = getOrdersBucket(turn);

  // Collect orders in display order
  const all = [];
  for(const f of ["allies","axis","ussr","custom"]){
    for(const o of bucket[f]) all.push(o);
  }
  // newest first
  all.sort((a,b) => (b.submittedAt||"").localeCompare(a.submittedAt||""));

  if(all.length === 0){
    const empty = document.createElement("div");
    empty.className = "hint";
    empty.textContent = "No orders yet for this turn.";
    list.appendChild(empty);
    return;
  }

  for(const o of all){
    if(!canViewOrder(o)) continue;

    const card = document.createElement("div");
    card.className = "orderCard";

    const top = document.createElement("div");
    top.className = "orderTop";
    top.innerHTML = `<span>${o.faction.toUpperCase()} • ${o.general}</span><span>${o.status || "draft"}</span>`;
    card.appendChild(top);

    const main = document.createElement("div");
    main.className = "orderMain";
    const toTxt = o.to ? ` → <b>${o.to}</b>` : "";
    const condTxt = o.condition ? `<br><span class="pill">IF</span> ${escapeHtml(o.condition)}` : "";
    const notesTxt = o.notes ? `<br><span class="pill">NOTE</span> ${escapeHtml(o.notes)}` : "";
    main.innerHTML =
      `<b>${o.type}</b> from <b>${o.from}</b>${toTxt}` + condTxt + notesTxt;
    card.appendChild(main);

    const btns = document.createElement("div");
    btns.className = "orderBtns";

    const jumpBtn = document.createElement("button");
    jumpBtn.textContent = "Go To";
    jumpBtn.onclick = () => {
      const t = byId.get(o.from);
      jumpTheatre(t.theatreId || t.theatreKey);
      setTimeout(()=>openPanel(o.from), 250);
    };
    btns.appendChild(jumpBtn);

    if(canEditOrder(o)){
      const delBtn = document.createElement("button");
      delBtn.textContent = "Delete";
      delBtn.onclick = () => deleteOrder(o.id);
      btns.appendChild(delBtn);
    } else {
      const ghost = document.createElement("button");
      ghost.textContent = "Locked";
      ghost.disabled = true;
      btns.appendChild(ghost);
    }

    card.appendChild(btns);
    list.appendChild(card);
  }
}

function deleteOrder(orderId){
  const turn = state._meta.turn;
  const bucket = getOrdersBucket(turn);
  for(const f of ["allies","axis","ussr","custom"]){
    const idx = bucket[f].findIndex(o => o.id === orderId);
    if(idx >= 0){
      if(!canEditOrder(bucket[f][idx])) return;
      bucket[f].splice(idx,1);
      saveState();
      renderOrdersList();
      return;
    }
  }
}

function cryptoId(){
  try{
    return crypto.randomUUID();
  }catch(e){
    return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now();
  }
}
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}

/* -------------------------
   Init
-------------------------- */
(async function bootstrap(){
  const data = await loadAppTheatres();
  TERRS = buildTerrsFromData(data);
  byId = new Map(TERRS.map(t => [t.id, t]));
  ensureAdjacencyIfMissing();
  state = loadState();

  await loadWorldSvg();
  bindTerritoriesToSvg();
  captureBaseViewBox();
  applyMode();
  refreshPhaseUI();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();

  window.addEventListener("resize", () => redrawEdges());
})();

</script>
</body>
</html>
