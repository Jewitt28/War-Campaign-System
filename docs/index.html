<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WAR! Campaign — Strategic Board</title>

<style>
  :root{
    --bg:#2b2721;
    --paper:#3a342c;
    --ink:#e9e3d7;
    --line:#6b5b3e;
    --muted:#bdb6a8;

    --allies:#c9b27c;
    --axis:#666666;
    --ussr:#b22222;
    --neutral:#888888;
    --custom:#d9d9d9;

    --weTint: rgba(201,178,124,.10);
    --eeTint: rgba(178,34,34,.10);
    --naTint: rgba(224,176,122,.10);
    --paTint: rgba(122,160,224,.10);
  }

  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;}
  #topbar{
    position:fixed; inset:0 0 auto 0; z-index:1000;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    padding:10px 12px; background:#1b1b1b; border-bottom:2px solid #444;
  }
  #topbar .title{font-weight:700; letter-spacing:1px; margin-right:auto;}
  #topbar button, #topbar select{
    background:#222; color:#eee; border:1px solid #555; padding:6px 10px; cursor:pointer;
  }
  #topbar button:hover{background:#333;}
  #topbar .smallLabel{color:var(--muted);font-size:12px;}

  #wrap{
    position:absolute; top:64px; left:0; right:430px; bottom:0;
    overflow:auto;
    background:
      radial-gradient(circle at 20% 10%, rgba(255,255,255,.04), transparent 40%),
      radial-gradient(circle at 80% 30%, rgba(255,255,255,.03), transparent 45%),
      repeating-linear-gradient(0deg, rgba(255,255,255,.035), rgba(255,255,255,.035) 24px, rgba(255,255,255,.02) 24px, rgba(255,255,255,.02) 48px);
  }
  #board{
    position:relative;
    width:1600px; height:1100px;
    margin:30px;
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.10)), var(--paper);
    border:3px solid var(--line);
    box-shadow:0 8px 30px rgba(0,0,0,.35);
  }

  /* World map stage */
  #mapStage{ position:absolute; inset:0; z-index:1; }
  #mapImg{
    position:absolute; inset:0;
    z-index:1;
    width:100%; height:100%;
    object-fit:contain;
    pointer-events:none;
    opacity:.25;
  }
  #svgHost{ position:absolute; inset:0;z-index: 2; }
  #svgHost svg{ width:100%; height:100%; display:block; }

  /* Territory boundaries (visible even in grey setup view) */
  #svgHost [data-territory-id]{
    stroke: rgba(0,0,0,.85);
    stroke-width: 0.35;
    vector-effect: non-scaling-stroke;
  }

  /* Edges overlay */
  #edges{
    position:absolute; inset:0;
    z-index:3;
    pointer-events:none;
  }
  #edges { background: transparent !important; }
  #edges rect { fill: none !important; }
  .edgeLine{ stroke: rgba(233,227,215,.25); stroke-width: 2; }
  .edgeLine.dim{ stroke: rgba(233,227,215,.12); }
  .edgeLine.strong{ stroke: rgba(233,227,215,.55); stroke-width: 3; }

  
  /* Theatre focus dimming */
  #svgHost .dimmed {
  opacity: 0.12 !important;
}

  .theatre{
    position:absolute; z-index:1;
    display:none;
    border:2px dashed rgba(233,227,215,.25);
    border-radius:10px; overflow:hidden;
  }
  .theatreHeader{
    display:flex; align-items:center; justify-content:space-between;
    padding:8px 10px;
    border-bottom:1px solid rgba(233,227,215,.18);
    background:rgba(0,0,0,.25);
    font-weight:700; letter-spacing:2px; font-size:13px;
  }
  .theatreBody{position:relative; height:100%;}

  #WE{left:40px;  top:40px;  width:740px; height:480px; background:var(--weTint);}
  #EE{left:820px; top:40px;  width:740px; height:480px; background:var(--eeTint);}
  #NA{left:40px;  top:560px; width:740px; height:480px; background:var(--naTint);}
  #PA{left:820px; top:560px; width:740px; height:480px; background:var(--paTint);}

  /* Territory piece */
  .node{
    position:absolute;
    width:28px; height:28px;
    border-radius:50%;
    border:2px solid #000;
    display:flex; align-items:center; justify-content:center;
    font-size:14px;
    cursor:pointer;
    user-select:none;
    box-shadow:0 2px 8px rgba(0,0,0,.35);
    z-index:3;
    transition: transform .08s ease, box-shadow .08s ease, outline-color .08s ease;
  }
  .node:hover{ transform: translateY(-1px); box-shadow:0 4px 12px rgba(0,0,0,.45); }

  .owner-allies{background:var(--allies); color:#111;}
  .owner-axis{background:var(--axis); color:#111;}
  .owner-ussr{background:var(--ussr); color:#111;}
  .owner-neutral{background:var(--neutral); color:#111;}
  .owner-custom{background:var(--custom); color:#111;}

  /* Fog: greyed but still visible */
  .fog-unknown{ filter: grayscale(1); opacity: .35; }

  /* Selection */
  .selected{ outline: 3px solid rgba(233,227,215,.70); outline-offset: 2px; }
  .adjacent{ outline: 3px solid rgba(233,227,215,.35); outline-offset: 2px; }

  /* Right drawer */
  #panel{
    position:fixed; top:64px; right:0; bottom:0; width:430px;
    background:#171717; border-left:2px solid #444;
    padding:12px; overflow:auto; display:none;
  }

  /* Panel title readability (no clipping) */
  #panel{ padding-top:14px; }
  #panel h2{
    margin-top:6px;
    line-height:1.2;
    white-space:normal;
    word-break:break-word;
  }

  #panel h2{margin:0 0 8px 0; font-size:16px;}
  .meta{color:var(--muted); font-size:12px; margin-bottom:10px;}
  .row{margin:10px 0;}
  .row label{display:block; font-size:12px; color:var(--muted); margin-bottom:4px;}
  .row select, .row textarea, .row input{
    width:100%; background:#222; color:#eee; border:1px solid #555; padding:6px 8px;
    box-sizing:border-box;
  }
  .row textarea{min-height:70px; resize:vertical;}
  .pill{
    display:inline-block; padding:2px 8px; border:1px solid rgba(255,255,255,.15);
    border-radius:999px; font-size:12px; color:#ddd; background:rgba(0,0,0,.25);
    margin-right:6px;
  }
  .btnRow{display:flex; gap:10px; margin-top:10px;}
  .btnRow button{flex:1;}
  .hint{font-size:12px; color:var(--muted); margin-top:10px; line-height:1.4;}
  .linkish{ color:#e9e3d7; text-decoration:underline; cursor:pointer; }
  .linkish:hover{ opacity:.85; }

  .grid2{
    display:grid;
    grid-template-columns: 90px 1fr;
    gap:6px 8px;
    align-items:center;
  }
  .grid2 .tag{ font-size:12px; color:var(--muted); }

  .hr{height:1px;background:rgba(255,255,255,.08); margin:14px 0;}

  .orderCard{
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    padding:8px;
    border-radius:10px;
    margin-top:8px;
  }
  .orderTop{
    display:flex; justify-content:space-between; gap:8px; align-items:center;
    font-size:12px; color:var(--muted);
  }
  .orderMain{ margin-top:6px; font-size:13px; }
  .orderBtns{ display:flex; gap:8px; margin-top:8px; }
  .orderBtns button{ flex:1; }

  /* Region (group) outlines */
  .regionBox { fill: rgba(0,0,0,0); stroke: rgba(233,227,215,.45); stroke-width: 2; stroke-dasharray: 8 6; }
  .regionLabel { fill: rgba(233,227,215,.9); font-weight: 800; letter-spacing: 2px; font-size: 14px; paint-order: stroke; stroke: rgba(0,0,0,.65); stroke-width: 3px; }


  /* Territory borders always visible (important with region fills) */
  #svgHost [data-territory-id]{
    stroke: rgba(0,0,0,.85);
    stroke-width: 0.35;
    vector-effect: non-scaling-stroke;
  }


  /* Region secured indicator */
  .regionBox.secured { stroke: rgba(255,220,120,.85); stroke-width: 3; filter: drop-shadow(0 0 10px rgba(255,220,120,.25)); }
  .regionLabel.secured { fill: rgba(255,230,160,.95); }

  /* Homeland marker */
  .homelandMark { fill: rgba(255,235,180,.95); paint-order: stroke; stroke: rgba(0,0,0,.7); stroke-width: 3px; font-weight: 900; font-size: 16px; pointer-events:none; }
  .homelandRing { fill: rgba(0,0,0,0); stroke: rgba(255,220,120,.8); stroke-width: 2; filter: drop-shadow(0 0 8px rgba(255,220,120,.25)); pointer-events:none; }

  /* Active effects panel */
  #effectsPanel{
    position:absolute;
    left:14px; bottom:14px;
    z-index:20;
    width:420px;
    max-height:240px;
    overflow:auto;
    padding:10px 12px;
    border:2px solid rgba(233,227,215,.25);
    background:rgba(0,0,0,.35);
    border-radius:10px;
    backdrop-filter: blur(4px);
    font-size:12px;
  }
  #effectsPanel h4{ margin:0 0 8px 0; font-size:12px; letter-spacing:2px; opacity:.9; }
  #effectsPanel .row{ display:flex; justify-content:space-between; gap:10px; padding:4px 0; border-bottom:1px solid rgba(233,227,215,.12); }
  #effectsPanel .row:last-child{ border-bottom:none; }
  #effectsPanel .tag{ opacity:.8; }
  #effectsPanel .owner{ font-weight:800; letter-spacing:1px; }
  #effectsPanel .effect{ opacity:.9; }

  /* Theatre lock */
  #lockWrap{ display:flex; align-items:center; gap:8px; }


  .regionBox.contested { stroke: rgba(233,227,215,.55); stroke-width: 2.5; }
  .regionLabel.contested { fill: rgba(233,227,215,.95); }
  .regionBox.neutral { stroke: rgba(233,227,215,.25); stroke-width: 2; stroke-dasharray: 10 8; }
  .regionLabel.neutral { fill: rgba(233,227,215,.70); }


  /* Setup checklist panel */
  #setupPanel{
    position:absolute;
    right:14px; bottom:14px;
    z-index:20;
    width:360px;
    max-height:260px;
    overflow:auto;
    padding:10px 12px;
    border:2px solid rgba(233,227,215,.25);
    background:rgba(0,0,0,.35);
    border-radius:10px;
    backdrop-filter: blur(4px);
    font-size:12px;
  }
  #setupPanel h4{ margin:0 0 8px 0; font-size:12px; letter-spacing:2px; opacity:.9; }
  #setupPanel .item{ display:flex; justify-content:space-between; gap:10px; padding:4px 0; border-bottom:1px solid rgba(233,227,215,.12); }
  #setupPanel .item:last-child{ border-bottom:none; }
  #setupPanel .ok{ color: rgba(180,255,180,.95); font-weight:800; }
  #setupPanel .warn{ color: rgba(255,210,140,.95); font-weight:800; }
  #setupPanel .bad{ color: rgba(255,160,160,.95); font-weight:800; }


  /* ===== Setup Mode polish ===== */
  body.setup-active #topBar{
    box-shadow: 0 0 0 2px rgba(255,90,90,.35) inset, 0 8px 30px rgba(0,0,0,.35);
  }
  #setupBadge{
    display:none;
    margin-left:10px;
    padding:4px 10px;
    border-radius:999px;
    border:1px solid rgba(255,90,90,.45);
    background: rgba(255,90,90,.18);
    color: rgba(255,210,210,.98);
    font-weight:900;
    letter-spacing:2px;
    font-size:12px;
    text-transform:uppercase;
  }
  body.setup-active #setupBadge{ display:inline-flex; align-items:center; gap:8px; }
  body.setup-active #setupBadge::before{ content:"●"; }

  body.setup-active .playOnly{
    opacity:.35;
    pointer-events:none;
    filter: grayscale(.35);
  }
  body.setup-active #rightPanelTitle{
    color: rgba(255,210,210,.95);
  }
  body.setup-active #rightPanelTitle::after{
    content:" — SETUP TOOLS";
    font-weight:900;
    letter-spacing:2px;
    opacity:.9;
  }

  #modeHint{
    display:none;
    margin-top:6px;
    font-size:12px;
    opacity:.9;
    line-height:1.3;
  }
  body.setup-active #modeHint{
    display:block;
    color: rgba(255,210,210,.92);
  }


  /* ===== Regions UI ===== */
  #panelTabs{ display:flex; gap:6px; margin:10px 0 6px; }
  #panelTabs button{
    flex:1;
    background:#222; color:#eee; border:1px solid #555; padding:6px 8px; cursor:pointer;
    font-weight:700; letter-spacing:1px;
  }
  #panelTabs button.active{ background:#3a342c; border-color:#8a7a52; }
  #regionPanel{ display:none; }
  #territoryPanel{ display:block; }
  #regionList{ max-height:300px; overflow:auto; border:1px solid rgba(255,255,255,.08); padding:8px; border-radius:10px; background:rgba(0,0,0,.15); }
  .regionRow{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:8px 8px; border-radius:10px; cursor:pointer;
    border:1px solid rgba(255,255,255,.06);
    margin-bottom:6px;
  }
  .regionRow:hover{ background:rgba(255,255,255,.06); }
  .regionName{ font-weight:800; }
  .regionMeta{ display:flex; align-items:center; gap:6px; flex-wrap:wrap; justify-content:flex-end; }
  .badge{
    font-size:11px; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14);
    background:rgba(0,0,0,.25); color:var(--ink);
  }
  .badge.ctrl{ border-color: rgba(120,200,120,.35); }
  .badge.cont{ border-color: rgba(255,190,120,.35); }
  .badge.neut{ border-color: rgba(200,200,200,.25); }
  .badge.part{ border-color: rgba(160,200,255,.35); }

  /* Region highlight on SVG paths */
  #svgHost .region-highlight{
    stroke: rgba(233,227,215,.95) !important;
    stroke-width: 1.6 !important;
    filter: drop-shadow(0 0 3px rgba(0,0,0,.55));
  }
  #svgHost .region-dim{
    opacity: .18 !important;
  }


  /* ===== Visibility: stronger territory borders ===== */
  #svgHost [data-territory-id]{
    stroke: rgba(0,0,0,.90);
    stroke-width: 0.8;
    vector-effect: non-scaling-stroke;
  }

  /* Pins overlay */
  #pins{
    position:absolute; inset:0;
    z-index:6;
    pointer-events:none;
  }
  .pinDot{ fill: rgba(233,227,215,.95); stroke: rgba(0,0,0,.65); stroke-width: 1; }
  .pinText{ fill: rgba(0,0,0,.9); font-weight: 800; font-size: 10px; letter-spacing: .5px; paint-order: stroke; stroke: rgba(233,227,215,.9); stroke-width: 2; }


  /* ===== Overlay SVG sizing (fix top-left white box issues) ===== */
  #edges, #pins, #regionBorders{
    width:100%;
    height:100%;
    display:block;
    background:transparent;
  }

  /* ===== Always-on region borders (stroke-only overlay) ===== */
  .rBorder{
    fill: none !important;
    stroke-linejoin: round;
    stroke-linecap: round;
    vector-effect: non-scaling-stroke;
    opacity: .85;
  }


  /* ===== Make territory borders visible (always) ===== */
  #svgHost svg path, #svgHost svg polygon, #svgHost svg rect{
    stroke: rgba(0,0,0,.65) !important;
    stroke-width: 0.8 !important;
    vector-effect: non-scaling-stroke;
  }

  /* ===== Region borders overlay placement ===== */
  #regionBorders{
    position:absolute;
    inset:0;
    z-index:4;
    pointer-events:none;
    width:100%;
    height:100%;
    display:block;
    background:transparent;
  }
  #edges{ z-index:5; }
  #pins{ z-index:6; }


  /* ===== Overlay layers positioning ===== */
  #svgHost{ position:absolute; inset:0; z-index:2; }
  #regionBorders{
    position:absolute; inset:0; z-index:4;
    pointer-events:none; width:100%; height:100%;
    background:transparent; display:block;
  }
  #edges{ position:absolute; inset:0; z-index:5; pointer-events:none; width:100%; height:100%; background:transparent; display:block; }
  #pins{ position:absolute; inset:0; z-index:6; pointer-events:none; width:100%; height:100%; background:transparent; display:block; }

  /* Force visible territory strokes */
  #svgHost svg path, #svgHost svg polygon, #svgHost svg rect{
    stroke: rgba(0,0,0,.70) !important;
    stroke-width: 0.9 !important;
    vector-effect: non-scaling-stroke;
  }


  #regionSelectBorders{
    position:absolute;
    inset:0;
    z-index:4.5;
    pointer-events:none;
    width:100%;
    height:100%;
    display:block;
    background:transparent;
  }
  .rBorderBase{ fill:none !important; opacity:.45; vector-effect:non-scaling-stroke; }
  .rBorderSel{ fill:none !important; opacity:.95; vector-effect:non-scaling-stroke; }


  /* Setup panel */
  .setupFactionItem{
    border:1px solid rgba(233,227,215,.25);
    border-radius:10px;
    padding:8px;
    background:rgba(0,0,0,.18);
    cursor:pointer;
  }
  .setupFactionItem.active{
    outline:2px solid rgba(233,227,215,.65);
    outline-offset:2px;
  }

</style>
</head>

<body>
  <div id="topbar">
    <div class="title">WAR! Campaign — Strategic Board</div>

    <span class="pill" id="turnPill">Turn 1</span>
    <span class="pill" id="phasePill">Strategic</span>

    <span class="smallLabel">Phase</span>
    <select id="phaseSel">
      <option value="Strategic">Strategic</option>
      <option value="Operations">Operations</option>
      <option value="Resolution">Resolution</option>
    </select>

    <button id="advanceBtn">Advance Phase</button>

    <span class="smallLabel">Auto-advance turn</span>
    <select id="autoAdvSel">
      <option value="on" selected>On</option>
      <option value="off">Off</option>
    </select>

    <span class="smallLabel">Mode</span>
    <select id="modeSel">
      <option value="GM">GM</option>
      <option value="PLAYER">Player</option>
    </select>

    <span class="smallLabel">Player Faction</span>
    <select id="playerFactionSel">
      <option value="allies">Allies</option>
      <option value="axis">Axis</option>
      <option value="ussr">USSR</option>
      <option value="custom">Custom</option>
    </select>

    <span class="smallLabel">Adjacency</span>
    <select class="playOnly" id="adjSel">
      <option value="off">Off</option>
      <option value="select" selected>On Select</option>
      <option value="always">Always</option>
    </select>


    <label class="smallLabel" style="display:flex;align-items:center;gap:6px;margin-left:6px;">
      <input type="checkbox" id="setupView" checked>
      Setup view
    </label>
    <button onclick="handleTheatreBtn(event, 'WE')">W. Europe</button>
    <button onclick="handleTheatreBtn(event, 'EE')">E. Europe</button>
    <button onclick="handleTheatreBtn(event, 'NA')">N. Africa</button>
    <button onclick="handleTheatreBtn(event, 'PA')">Pacific</button>
    <button onclick="resetWorldView()">World</button>

  <span style="margin-left:14px; display:flex; gap:8px; align-items:center;">
    <strong style="letter-spacing:2px; opacity:.85;">ZOOM</strong>
    <button id="btnZoomIn" title="Zoom in">+</button>
    <button id="btnZoomOut" title="Zoom out">−</button>
    <button id="btnZoomReset" title="Fit to active theatres">Fit</button>
  </span>

    <button onclick="exportState()">Export</button>
    <button onclick="importState()">Import</button>
    <button onclick="resetState()">Reset</button>
    
  </div>

  <div id="wrap">
    <div id="board">
      <div id="mapStage">
        <div id="svgHost"></div>
  <div id=\"effectsPanel\" style=\"display:none;\"></div>

        <svg id="regionBorders" style="display:none;"></svg>
      <svg id="edges"></svg>
    <svg id="pins"></svg>
      </div>
<div id="WE" class="theatre">
        <div class="theatreHeader"><span>WESTERN EUROPE</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="WE"></div>
      </div>

      <div id="EE" class="theatre">
        <div class="theatreHeader"><span>EASTERN EUROPE</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="EE"></div>
      </div>

      <div id="NA" class="theatre">
        <div class="theatreHeader"><span>NORTH AFRICA</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="NA"></div>
      </div>

      <div id="PA" class="theatre">
        <div class="theatreHeader"><span>PACIFIC</span><span class="pill">15</span></div>
        <div class="theatreBody" data-theatre="PA"></div>
      </div>
    </div>
  </div>

  <aside id="panel">
    <h2 id="pTitle"></h2>
    <div class="meta">
      <span class="pill" id="pTheatre"></span>
      <span class="pill" id="pId"></span>
    </div>
    <div id="panelTabs">
      <button id="tabTerritory" class="active" type="button">TERRITORY</button>
      <button id="tabSetup" type="button">SETUP</button>
      <button id="tabRegions" type="button" style="display:none;">REGIONS</button>
    </div>
    <div id="territoryPanel">



    <!-- Faction HQ quick view -->
    <div class="row">
      <label>Faction HQ (Quick)</label>
      <div class="hint" id="hqQuick"></div>
      <div class="btnRow" id="hqBtns" style="display:none;">
        <button onclick="gmAdjustResources(+1)">+1 Res</button>
        <button onclick="gmAdjustResources(-1)">-1 Res</button>
      </div>
      <div class="hint" style="margin-top:8px;">
        Resource collection happens automatically at start of Strategic: +1 per controlled territory (simple baseline).
      </div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <label>Adjacency</label>
      <div id="adjList" class="hint"></div>
      <div class="hint">Tip: click a neighbour to jump/highlight.</div>
    </div>

    <div class="hr"></div>

    <!-- Movement Helper -->
    <div class="row">
      <label>Movement Helper</label>
      <div class="hint">
        <div><span class="pill">From</span> <span id="mvFrom">—</span></div>
        <div style="margin-top:6px;"><span class="pill">To</span> <span id="mvTo">—</span></div>
      </div>
      <div class="btnRow" style="margin-top:10px;">
        <button onclick="setMoveFromCurrent()">Set as Origin</button>
        <button onclick="trySetMoveToCurrent()">Set as Destination</button>
      </div>
      <div class="btnRow" style="margin-top:10px;">
        <button onclick="logMove()">Log Move</button>
        <button onclick="clearMove()">Clear</button>
      </div>
      <div id="mvHint" class="hint"></div>
      <div id="mvOptions" class="hint" style="margin-top:10px;"></div>
    </div>

    <div class="hr"></div>

    <!-- Orders -->
    <div class="row">
      <label>Orders (Operations Phase)</label>
      <div class="hint" id="ordersHint"></div>

      <div class="row">
        <label>General Name</label>
        <input id="orderGeneral" placeholder="e.g. Gen. Montgomery" />
      </div>

      <div class="row">
        <label>Order Type</label>
        <select id="orderType">
          <option value="Move">Move</option>
          <option value="Attack">Attack</option>
          <option value="Recon">Recon</option>
          <option value="Withdraw">Withdraw</option>
          <option value="Bombard">Bombard</option>
          <option value="Hold">Hold</option>
        </select>
      </div>

      <div class="row">
        <label>From (use current territory or pick)</label>
        <select id="orderFrom"></select>
      </div>

      <div class="row">
        <label>To (optional; for Move/Attack/Recon/Bombard/Withdraw)</label>
        <select id="orderTo"></select>
        <div class="hint" style="margin-top:8px;">Move/Attack/etc must be adjacent. Hold ignores To.</div>
      </div>

      <div class="row">
        <label>Condition (optional; 1 binary condition max)</label>
        <input id="orderCond" placeholder='e.g. "If enemy present, Withdraw; else Move"' />
      </div>

      <div class="row">
        <label>Notes</label>
        <input id="orderNotes" placeholder="Any extra detail for GM." />
      </div>

      <div class="btnRow">
        <button onclick="createOrder()">Add Order</button>
        <button onclick="closePanel()">Close</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        Player orders are hidden from other factions until Resolution. After Ops ends, orders lock.
      </div>

      <div id="ordersList"></div>
    </div>

    <div class="hr"></div>

    <div id="playerInfo" class="row" style="display:none;">
      <div class="hint">Player view: Unknown territories stay visible but greyed.</div>
    </div>

    <div id="gmControls" style="display:none;">
      <div class="row">
        <label>Owner</label>
        <select id="ownerSel">
          <option value="neutral">Neutral</option>
          <option value="allies">Allies</option>
          <option value="axis">Axis</option>
          <option value="ussr">USSR</option>
          <option value="custom">Custom</option>
        </select>
      </div>

      <div class="row">
        <label>Visibility (per faction)</label>
        <div class="grid2">
          <div class="tag">Allies</div>
          <select id="visAllies"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
          <div class="tag">Axis</div>
          <select id="visAxis"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
          <div class="tag">USSR</div>
          <select id="visUSSR"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
          <div class="tag">Custom</div>
          <select id="visCustom"><option>Unknown</option><option>Known</option><option>Observed</option><option>Confirmed</option></select>
        </div>
      </div>

      <div class="row">
        <label>GM Notes</label>
        <textarea id="notes"></textarea>
      </div>

      <div class="btnRow">
        <button onclick="saveTerritory()">Save Territory</button>
        <button onclick="closePanel()">Close</button>
      </div>
    </div>

    <div class="hint" style="margin-top:14px;">
      Icons: ★ Allies, ✚ Axis, ☭ USSR, ⚑ Custom, ● Neutral
    </div>
  
    </div><!-- /territoryPanel -->

    <div id="regionPanel" style="display:none;">
      <h3 style="margin:8px 0 6px;">Regions</h3>
      <div class="hint">Click a region to highlight its territories and view control status.</div>
      <div style="display:flex; gap:8px; align-items:center; margin:10px 0;">
        <label style="display:flex; gap:8px; align-items:center; cursor:pointer;">
          <input id="toggleRegionDim" type="checkbox" />
          Dim non-region territories
        </label>
      </div>
      <div id="regionList"></div>
      <div class="hr"></div>
      <div id="regionDetails" class="hint"></div>
    </div>

    <div id="setupPanel" style="display:none;">
      <h3 style="margin:8px 0 6px;">Campaign Setup</h3>
      <div class="hint">Setup is a one-time phase. Locking setup switches to PLAY and cannot be re-entered.</div>

      <div class="row" style="margin-top:10px;">
        <label>Active Theatres</label>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <label style="display:flex; gap:8px; align-items:center;"><input id="stWE" type="checkbox"> Western Europe</label>
          <label style="display:flex; gap:8px; align-items:center;"><input id="stEE" type="checkbox"> Eastern Europe</label>
          <label style="display:flex; gap:8px; align-items:center;"><input id="stNA" type="checkbox"> North Africa</label>
          <label style="display:flex; gap:8px; align-items:center;"><input id="stPA" type="checkbox"> Pacific</label>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <label>Custom Factions</label>
        <div class="hint">Add player factions here. Pick a faction, then click a territory on the map to set its Homeland (and initial owner).</div>

        <div style="display:flex; gap:8px; margin-top:8px;">
          <input id="newFactionName" placeholder="Faction name" style="flex:1; padding:8px; border:1px solid rgba(233,227,215,.25); background:rgba(0,0,0,.25); color:inherit; border-radius:8px;">
          <input id="newFactionColor" type="color" value="#888888" style="width:46px; height:38px; border:1px solid rgba(233,227,215,.25); background:rgba(0,0,0,.25); border-radius:8px;">
        </div>
        <div class="btnRow" style="margin-top:8px;">
          <button id="btnAddFaction" type="button">Add Faction</button>
          <button id="btnClearFactionSel" type="button">Clear Selection</button>
        </div>

        <div id="setupFactionList" style="margin-top:10px; display:flex; flex-direction:column; gap:8px;"></div>
        <div class="hint" id="setupHint" style="margin-top:10px;"></div>
      </div>

      <div class="btnRow" style="margin-top:12px;">
        <button id="btnLockSetup" type="button" style="background:rgba(140,54,54,.55); border-color:rgba(233,227,215,.35);">LOCK SETUP → START PLAY</button>
      </div>
    </div>
</aside>

<script>

// ===== Bootstrap guards (prevents ReferenceError on early calls) =====
window.DATA = window.DATA || null;
window.state = window.state || {};
// IMPORTANT: Do NOT declare `var state` or `var DATA` here, because the base app declares them.
// Use window.DATA / window.state instead. Call syncGlobals() after data/state are created.
function syncGlobals(){
  try{ if(typeof DATA !== 'undefined') window.DATA = DATA; }catch(_){}
  try{ if(typeof state !== 'undefined') window.state = state; }catch(_){}
}
// Fallback ownerToColor if not defined in base file
if(typeof ownerToColor !== 'function'){
  function ownerToColor(ownerKey){
    const cs = getComputedStyle(document.documentElement);
    const pick = (v, d) => (v && v.trim()) ? v.trim() : d;
    const map = {
      allies: pick(cs.getPropertyValue('--allies'), '#8fb8d8'),
      axis: pick(cs.getPropertyValue('--axis'), '#d0a06a'),
      ussr: pick(cs.getPropertyValue('--ussr'), '#c85b5b'),
      neutral: pick(cs.getPropertyValue('--neutral'), '#d1dbdd'),
      custom: pick(cs.getPropertyValue('--custom'), '#cccccc')
    };
    return map[(ownerKey||'neutral').toLowerCase()] || map.neutral;
  }
}
// Safe getViewBox fallback if missing/returns null
if(typeof getViewBox !== 'function'){
  function getViewBox(svg){
    const vb = svg?.getAttribute?.('viewBox');
    if(!vb) return null;
    const parts = vb.split(/\s+/).map(Number);
    return (parts.length===4 && parts.every(n => Number.isFinite(n))) ? parts : null;
  }
}




/** Fixed positions (15 slots) used in every theatre panel */
const POS15 = [
  [140,110],[230,90],[330,95],[440,90],
  [120,190],[230,185],[340,190],[460,185],
  [140,270],[245,290],[350,280],[455,290],
  [200,360],[360,360],
  [280,410]
];

const THEATRE_NAME = {WE:"Western Europe", EE:"Eastern Europe", NA:"North Africa", PA:"Pacific"};
const OWNER_ICON = {allies:"★", axis:"✚", ussr:"☭", neutral:"●", custom:"⚑"};
const HUBS = new Set(["WE-02","WE-08","WE-09","NA-05","NA-15","PA-02","PA-07","PA-15"]);
const CHOKES = new Map([
  ["WE-14","Gibraltar"],
  ["NA-15","Suez"]
]);
const STORAGE_KEY = "war_board_state_v3";

/** Territories loaded from theatres_all.json */
let TERRS = [];
let byId = new Map();

async function loadAppTheatres(){
  // Try common locations (repo layouts differ). First hit wins.
  const candidates = [
    'docs/theatres_all.json',
    'theatres_all.json',
    'assets/theatres_all.json',
  ];
  let lastErr = null;
  for(const url of candidates){
    try{
      const res = await fetch(url, { cache: 'no-store' });
      if(res.ok) return await res.json();
      lastErr = new Error(`HTTP ${res.status} for ${url}`);
    }catch(e){
      lastErr = e;
    }
  }
  throw new Error(`Failed to load theatres_all.json from any known path. Last error: ${lastErr}`);
}

async function loadRegionGroups(){
  const candidates = [
    'docs/region_groups.json',
    'region_groups.json',
    'docs/region_groups_by_fill.json',
    'region_groups_by_fill.json',
  ];
  let lastErr = null;
  for(const url of candidates){
    try{
      const res = await fetch(url, { cache: 'no-store' });
      if(res.ok) return await res.json();
      lastErr = new Error(`HTTP ${res.status} for ${url}`);
    }catch(e){
      lastErr = e;
    }
  }
  // Regions optional; return empty if missing
  console.warn('No region_groups.json found in known paths.');
  return { schemaVersion:'1.0', groups: [] };
}
async function loadWorldSvg(){
  const res = await fetch('assets/mapchart_world.svg', { cache:'no-store' });
  if(!res.ok) throw new Error(`Failed to load map SVG: ${res.status}`);
  const svgText = await res.text();
  document.getElementById('svgHost').innerHTML = svgText;

  // ensure the injected svg is findable
  const svg = document.querySelector('#svgHost svg');
  
  if(!svg) throw new Error("SVG did not load correctly into #svgHost.");

  svg.setAttribute('preserveAspectRatio','xMidYMid meet');
  return svg;
}
let baseViewBox = null;

function getSvg() {
  return document.querySelector('#svgHost svg');
}

function captureBaseViewBox() {
  const svg = getSvg();
  if (!svg) return;

  // Ensure a viewBox exists
  if (!svg.hasAttribute('viewBox')) {
    const b = svg.getBBox();
    svg.setAttribute('viewBox', `${b.x} ${b.y} ${b.width} ${b.height}`);
  }
  baseViewBox = svg.getAttribute('viewBox');
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
}

function resetWorldView() {
  const svg = getSvg();
  if (!svg || !baseViewBox) return;

  focusedTheatre = null;

  const from = getViewBox(svg) || baseViewBox.split(/\\s+/).map(Number);
  const to = baseViewBox.split(/\\s+/).map(Number);
  animateViewBox(svg, from, to, 260);

  svg.querySelectorAll('[data-territory-id]').forEach(el => el.classList.remove('dimmed'));

  redrawEdges();
  /* regions parked */
}

// Returns array of DOM elements belonging to theatre territories
function theatreElements(theatreId) {
  const svg = getSvg();
  if (!svg) return [];

  const ids = TERRS
    .filter(t => t.theatreKey === theatreId)
    .map(t => t.id);

  const els = [];
  for (const tid of ids) {
    svg.querySelectorAll(`[data-territory-id="${tid}"]`).forEach(el => els.push(el));
  }
  return els;
}

function focusTheatre(theatreId) {
  const svg = getSvg();
  if (!svg) return;

  // Dim everything first
  svg.querySelectorAll('[data-territory-id]').forEach(el => el.classList.add('dimmed'));

  // Undim this theatre
  const els = theatreElements(theatreId);
  els.forEach(el => el.classList.remove('dimmed'));
}

function zoomToElements(els, padFrac = 0.12) {
  const svg = getSvg();
  if (!svg || !els.length) return;

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const el of els) {
    const b = el.getBBox();
    minX = Math.min(minX, b.x);
    minY = Math.min(minY, b.y);
    maxX = Math.max(maxX, b.x + b.width);
    maxY = Math.max(maxY, b.y + b.height);
  }

  const w = maxX - minX;
  const h = maxY - minY;
  const padX = w * padFrac;
  const padY = h * padFrac;

  const x = minX - padX;
  const y = minY - padY;
  const vw = w + padX * 2;
  const vh = h + padY * 2;

  svg.setAttribute('viewBox', `${x} ${y} ${vw} ${vh}`);
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
}

// Main: theatre button handler

// ---------- Smooth viewBox animation ----------
let _vbAnim = null;
function animateViewBox(svg, from, to, ms=260){
  if(_vbAnim) cancelAnimationFrame(_vbAnim);
  const t0 = performance.now();
  function step(now){
    const t = Math.min(1, (now - t0) / ms);
    const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2, 2)/2;
    const cur = from.map((v,i)=> v + (to[i]-v)*ease);
    svg.setAttribute('viewBox', cur.join(' '));
    if(t < 1) _vbAnim = requestAnimationFrame(step);
  }
  _vbAnim = requestAnimationFrame(step);
}
function getViewBox(svg){
  const vb = (svg.getAttribute('viewBox') || '').trim();
  if(!vb) return null;
  return vb.split(/\s+/).map(Number);
}
function zoomToBBoxAnimated(svg, bbox, padFrac=0.12){
  const padX = bbox.width * padFrac;
  const padY = bbox.height * padFrac;
  const to = [bbox.x - padX, bbox.y - padY, bbox.width + padX*2, bbox.height + padY*2];
  const from = getViewBox(svg) || to;
  animateViewBox(svg, from, to, 260);
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
}

// ---------- Regions (territory groups) overlay ----------
function getRegionsForTheatre(theatreId){
  const th = (DATA?.theatres || []).find(t => t.theatreId === theatreId);
  if(!th) return [];
  if(Array.isArray(th.regions) && th.regions.length) return th.regions;
  // default: one region = whole theatre
  return [{
    id: theatreId,
    title: th.title || theatreId,
    territoryIds: (th.territories||[]).map(x=>x.id),
  }];
}
function elementsForTerritories(ids){
  const svg = getSvg();
  if(!svg) return [];
  const els = [];
  for(const tid of ids){
    svg.querySelectorAll(`[data-territory-id="${tid}"]`).forEach(el => els.push(el));
  }
  return els;
}
function bboxForElements(els){
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for(const el of els){
    const b = el.getBBox();
    minX = Math.min(minX, b.x);
    minY = Math.min(minY, b.y);
    maxX = Math.max(maxX, b.x + b.width);
    maxY = Math.max(maxY, b.y + b.height);
  }
  if(!isFinite(minX)) return null;
  return { x:minX, y:minY, width:maxX-minX, height:maxY-minY };
}
function clearRegionOverlay(){
  if(!edgesSvg) return;
  edgesSvg.querySelectorAll('.regionBox, .regionLabel').forEach(n => n.remove());
}
function drawRegionBox(bbox, label){
  const pad = 10;
  const x = bbox.x - pad, y = bbox.y - pad, w = bbox.width + pad*2, h = bbox.height + pad*2;
  const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
  r.setAttribute('x', x); r.setAttribute('y', y);
  r.setAttribute('width', w); r.setAttribute('height', h);
  r.setAttribute('rx', 12); r.setAttribute('ry', 12);
  r.setAttribute('class', 'regionBox');
  edgesSvg.appendChild(r);

  const t = document.createElementNS("http://www.w3.org/2000/svg","text");
  t.setAttribute('x', x + 14);
  t.setAttribute('y', y + 22);
  t.setAttribute('class', 'regionLabel');
  t.textContent = label;
  edgesSvg.appendChild(t);
}

let focusedTheatre = null;
function redrawRegions(){
  const show = document.getElementById('regionsView')?.checked;
  clearRegionOverlay();
  if(!show) return;

  const theatres = (DATA?.theatres || []).map(t=>t.theatreId);
  const list = focusedTheatre ? [focusedTheatre] : theatres;

  for(const thId of list){
    const regions = getRegionsForTheatre(thId);
    for(const reg of regions){
      const els = elementsForTerritories(reg.territoryIds || []);
      const bb = bboxForElements(els);
      if(!bb) continue;
      drawRegionBox(bb, reg.title || reg.id || thId);
    }
  }
}

function jumpTheatre(theatreId) {
  const els = theatreElements(theatreId);
  if (!els.length) {
    console.warn('No SVG elements found for theatre', theatreId);
    return;
  }
  focusedTheatre = theatreId;
  focusTheatre(theatreId);

  const bb = bboxForElements(els);
  if (bb) zoomToBBoxAnimated(getSvg(), bb, 0.12);

  redrawEdges();
  /* regions parked */
}

// Create one clickable "territory group" for all its shapeRefs
function bindTerritoriesToSvg(){
  const svg = document.querySelector('#svgHost svg');
  if(!svg) return;

  const shapeToPath = new Map();
  svg.querySelectorAll('path[id], polygon[id]').forEach(p => shapeToPath.set(p.id, p));

  // Expand refs like "France_FR_2-9" into ["France_FR_2",...,"France_FR_9"]
  function expandShapeRef(ref){
    const m = ref.match(/^(.*_)(\d+)-(\d+)$/);
    if(!m) return [ref];
    const prefix = m[1];
    const a = parseInt(m[2], 10);
    const b = parseInt(m[3], 10);
    if(!Number.isFinite(a) || !Number.isFinite(b)) return [ref];
    const start = Math.min(a,b), end = Math.max(a,b);
    const out = [];
    for(let n=start; n<=end; n++) out.push(prefix + n);
    return out;
  }

  for(const t of TERRS){
    const refs = t.shapeRefs || [];
    for(const raw of refs){
      for(const ref of expandShapeRef(raw)){
        const path = shapeToPath.get(ref);
        if(!path){
          console.warn('Missing SVG path for shapeRef:', ref, 'territory:', t.id);
          continue;
        }
        
        // store original MapChart fill so we can revert for neutral owner
        if(!path.dataset.baseFill){
          const base = path.getAttribute('fill') || getComputedStyle(path).fill;
          path.dataset.baseFill = base;
        }
path.setAttribute('data-territory-id', t.id);
        path.style.cursor = 'pointer';

        // Tooltip (only add once)
        if(!path.querySelector('title')){
          const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
          title.textContent = `${t.id} — ${t.name}`;
          path.appendChild(title);
        }

        path.addEventListener('click', (e) => {
          e.stopPropagation();
          if(handleSetupTerritoryClick(t.id)) return;
          openPanel(t.id);
        });
      }
    }
  }
}

// Style fills based on owner + fog, and compute centers for adjacency drawing

// ---------- Region color mapping (Risk-style) ----------
let TERRITORY_TO_REGION = new Map();   // tid -> region object
let REGION_BY_ID = new Map();          // regionId -> region object

function buildRegionMaps(){
  TERRITORY_TO_REGION = new Map();
  REGION_BY_ID = new Map();
  for(const th of (DATA_LOCAL?.theatres || [])){
    for(const reg of (th.regions || [])){
      if(reg?.id) REGION_BY_ID.set(reg.id, reg);
      for(const tid of (reg.territoryIds || [])){
        TERRITORY_TO_REGION.set(tid, reg);
      }
    }
  }
}
function regionColorForTerritory(tid){
  const reg = TERRITORY_TO_REGION.get(tid);
  return (reg && reg.color) ? reg.color : null;
}

function rerenderSvgFills() {
  const svg = getSvg();
  if(!svg) return;

  const setup = document.getElementById('setupView')?.checked;
  const neutralGrey = getComputedStyle(document.documentElement).getPropertyValue('--neutral').trim() || '#d1dbdd';

  svg.querySelectorAll('[data-territory-id]').forEach(el => {
    const tid = el.dataset.territoryId;
    const owner = (state?.[tid]?.owner) || 'neutral';

    // BASE fill:
    // - Setup view: neutral grey
    // - Normal view: region colour (Risk-style)
    const regionCol = regionColorForTerritory(tid);
    const baseFill = setup ? neutralGrey : (regionCol || neutralGrey);

    // If owned, show owner colour; else show baseFill
    el.style.fill = (owner && owner !== 'neutral') ? ownerToColor(owner) : baseFill;

    // Keep borders crisp
    el.style.opacity = '1';
  });
}


// Get centroid from combined bboxes of all SVG paths in a territory
function territoryCenterOnSvg(territoryId){
  const paths = Array.from(document.querySelectorAll(`#svgHost [data-territory-id="${territoryId}"]`));
  if(!paths.length) return null;

  // union bbox
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const p of paths){
    const b = p.getBBox();
    minX = Math.min(minX, b.x);
    minY = Math.min(minY, b.y);
    maxX = Math.max(maxX, b.x + b.width);
    maxY = Math.max(maxY, b.y + b.height);
  }

  // Convert SVG coordinates into screen coords:
  const svg = document.querySelector('#svgHost svg');
  const pt = svg.createSVGPoint();
  pt.x = (minX + maxX) / 2;
  pt.y = (minY + maxY) / 2;

  const ctm = svg.getScreenCTM();
  if(!ctm) return null;
  const sp = pt.matrixTransform(ctm);

  // Convert screen -> board local coords (so your edges SVG can draw correctly)
  const boardRect = board.getBoundingClientRect();
  return { x: sp.x - boardRect.left, y: sp.y - boardRect.top };
}

function buildTerrsFromData(data){
  const out = [];
  for(const theatre of data.theatres){
    for(const terr of theatre.territories){
      const adjRaw = theatre.adjacency?.[terr.id];

      // Support adjacency formats:
      //  - { land:[...], sea:[...] }
      //  - [ ... ] (treated as land)
      let land = [], sea = [];
      if(Array.isArray(adjRaw)){
        land = adjRaw;
      } else if(adjRaw && typeof adjRaw === 'object'){
        land = adjRaw.land || [];
        sea  = adjRaw.sea  || [];
      }
      const combined = Array.from(new Set([...land, ...sea]));
      const adj = { land, sea };
      out.push({
        id: terr.id,
        name: terr.name,
        theatreKey: theatre.theatreId,
        shapeRefs: terr.shapeRefs || [],
        adj: combined,
        adjLand: adj.land || [],
        adjSea: adj.sea || []
      });
    }
  }
  out.sort((a,b)=> a.id.localeCompare(b.id));
  return out;
}


function ensureAdjacencyIfMissing(){
  // If ANY territory already has adjacency, assume real adjacency exists
  const hasAny = TERRS.some(t => (t.adj && t.adj.length));
  if(hasAny) return;

  console.warn("No adjacency data found in theatres_all.json; using fallback adjacency (simple theatre chains + a few links).");

  // Group by theatre
  const groups = {};
  for(const t of TERRS){
    (groups[t.theatreKey] ||= []).push(t);
  }
  // Chain by sorted id within each theatre: A<->B<->C...
  for(const key of Object.keys(groups)){
    const arr = groups[key].slice().sort((a,b)=>a.id.localeCompare(b.id));
    for(let i=0;i<arr.length;i++){
      const here = arr[i];
      const neigh = new Set(here.adj || []);
      if(i>0) neigh.add(arr[i-1].id);
      if(i<arr.length-1) neigh.add(arr[i+1].id);
      here.adj = Array.from(neigh);
      here.adjLand = Array.from(neigh); // treat as land for now
      here.adjSea = [];
    }
  }

  // A few WW2-flavoured inter-theatre links (treated as sea lanes)
  function link(a,b){
    const A = byId.get(a), B = byId.get(b);
    if(!A || !B) return;
    if(!A.adj.includes(b)) A.adj.push(b);
    if(!B.adj.includes(a)) B.adj.push(a);
    if(!A.adjSea.includes(b)) A.adjSea.push(b);
    if(!B.adjSea.includes(a)) B.adjSea.push(a);
  }
  // Gibraltar / Morocco
  link("WE-14","NA-01");
  // Sicily <-> Tunis / Tripoli
  link("WE-11","NA-05");
  link("WE-11","NA-06");
  // Suez lane toward Malaya (strategic route)
  link("NA-15","PA-07");
}

const board = document.getElementById("board");
const edgesSvg = document.getElementById("edges");

const modeSel = document.getElementById("modeSel");
const playerFactionSel = document.getElementById("playerFactionSel");
const adjSel = document.getElementById("adjSel");

const phaseSel = document.getElementById("phaseSel");
const advanceBtn = document.getElementById("advanceBtn");
const autoAdvSel = document.getElementById("autoAdvSel");

const turnPill = document.getElementById("turnPill");
const phasePill = document.getElementById("phasePill");

let state = null;
let currentId = null;

/* Movement helper state */
let moveFrom = null;
let moveTo = null;

modeSel.addEventListener("change", () => {
  applyMode();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshMoveUI();
  refreshHQQuick();
  refreshOrdersUI();
  refreshPhaseUI();
});

playerFactionSel.addEventListener("change", () => {
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshMoveUI();
  refreshHQQuick();
  refreshOrdersUI();
});

adjSel.addEventListener("change", () => redrawEdges());


const setupViewEl = document.getElementById("setupView");
setupViewEl?.addEventListener("change", () => {
  rerenderSvgFills();
  redrawEdges();
});


phaseSel.addEventListener("change", () => {
  // Players can't change phase
  if(modeSel.value !== "GM"){
    refreshPhaseUI();
    return;
  }
  setPhase(phaseSel.value, {manual:true});
});

autoAdvSel.addEventListener("change", () => {
  state._meta.autoAdvanceTurn = (autoAdvSel.value === "on");
  saveState();
});

advanceBtn.addEventListener("click", () => {
  if(modeSel.value !== "GM") return;
  advancePhase();
});

function scrollToTheatre(key){
  document.getElementById(key)?.scrollIntoView({behavior:"smooth", block:"start", inline:"nearest"});
}
function defaultMeta(){
  return {
    turn: 1,
    phase: "Strategic",
    autoAdvanceTurn: true,
    moveLog: [],
    orders: {},   // orders[turn][faction] = []
    factions: {
      allies:{resources:0},
      axis:{resources:0},
      ussr:{resources:0},
      custom:{resources:0}
    },
    // Setup (one-time)
    mode: "PLAY", // PLAY | SETUP
    setupLocked: false,
    activeTheatres: {WE:true, EE:true, NA:false, PA:false},
    customFactions: [], // [{id,name,color}]
    homelands: {},      // {factionKeyOrId: territoryId}
    selectedSetupFaction: null
  };
}


function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      // Territory backfill
      for(const t of TERRS){
        if(!parsed[t.id]) parsed[t.id] = {};
        parsed[t.id].owner = parsed[t.id].owner || "neutral";
        parsed[t.id].vis = parsed[t.id].vis || {allies:"Known", axis:"Known", ussr:"Known", custom:"Known"};
        parsed[t.id].notes = parsed[t.id].notes || "";
      }
      // Meta backfill
      parsed._meta = parsed._meta || defaultMeta();
      parsed._meta.turn = typeof parsed._meta.turn === "number" ? parsed._meta.turn : 1;
      parsed._meta.phase = parsed._meta.phase || "Strategic";
      parsed._meta.autoAdvanceTurn = (parsed._meta.autoAdvanceTurn !== false);
      parsed._meta.moveLog = Array.isArray(parsed._meta.moveLog) ? parsed._meta.moveLog : [];
      parsed._meta.orders = parsed._meta.orders || {};
      parsed._meta.factions = parsed._meta.factions || defaultMeta().factions;
      for(const f of ["allies","axis","ussr","custom"]){
        if(!parsed._meta.factions[f]) parsed._meta.factions[f] = {resources:0};
        if(typeof parsed._meta.factions[f].resources !== "number") parsed._meta.factions[f].resources = 0;
      }
      return parsed;
    }
  }catch(e){}
  const s = {};
  for(const t of TERRS){
    s[t.id] = {
      owner:"neutral",
      vis:{allies:"Known", axis:"Known", ussr:"Known", custom:"Known"},
      notes:""
    };
  }
  s._meta = defaultMeta();
  return s;
}
// ===== Setup Mode (A: one-time setup, then locked) =====
function ensureSetupDefaults(){
  if(!state._meta) state._meta = defaultMeta();
  // backfill meta keys in older saves
  if(!state._meta.mode) state._meta.mode = "PLAY";
  if(typeof state._meta.setupLocked !== "boolean") state._meta.setupLocked = false;
  if(!state._meta.activeTheatres) state._meta.activeTheatres = {WE:true, EE:true, NA:false, PA:false};
  if(!Array.isArray(state._meta.customFactions)) state._meta.customFactions = [];
  if(!state._meta.homelands) state._meta.homelands = {};
  if(!("selectedSetupFaction" in state._meta)) state._meta.selectedSetupFaction = null;
}

function setMetaMode(mode){
  state._meta.mode = mode;
  saveState();
  applyMode();
}

function applyMode(){
  const setupOn = (state._meta.mode === "SETUP");
  const territoryPanel = document.getElementById("territoryPanel");
  const setupPanel = document.getElementById("setupPanel");
  const regionPanel = document.getElementById("regionPanel");

  // Drive the existing "Setup View" checkbox (controls grey planning fills)
  const cb = document.getElementById("setupView");
  if(cb) cb.checked = setupOn;

  if(setupOn){
    if(territoryPanel) territoryPanel.style.display = "none";
    if(regionPanel) regionPanel.style.display = "none";
    if(setupPanel) setupPanel.style.display = "block";
  }else{
    if(setupPanel) setupPanel.style.display = "none";
    if(territoryPanel) territoryPanel.style.display = "block";
    if(regionPanel) regionPanel.style.display = "none";
  }

  // Repaint SVG fills based on the checkbox + owner colours
  if(typeof applyHybridPlanningFills === "function") applyHybridPlanningFills();
  if(typeof rerenderSvgFills === "function") rerenderSvgFills();
}



function wireSetupUI(){
  const tabSetup = document.getElementById("tabSetup");
  const tabTerr = document.getElementById("tabTerritory");
  const tabReg = document.getElementById("tabRegions");
  const territoryPanel = document.getElementById("territoryPanel");
  const setupPanel = document.getElementById("setupPanel");
  const regionPanel = document.getElementById("regionPanel");

  function activate(btn){
    [tabTerr, tabSetup, tabReg].forEach(b=>{ if(b) b.classList.remove("active"); });
    if(btn) btn.classList.add("active");
  }
  if(tabTerr){
    tabTerr.addEventListener("click", ()=>{
      activate(tabTerr);
      if(territoryPanel) territoryPanel.style.display = "block";
      if(setupPanel) setupPanel.style.display = "none";
      if(regionPanel) regionPanel.style.display = "none";
    });
  }
  if(tabSetup){
    tabSetup.addEventListener("click", ()=>{
      activate(tabSetup);
      if(territoryPanel) territoryPanel.style.display = "none";
      if(regionPanel) regionPanel.style.display = "none";
      if(setupPanel) setupPanel.style.display = "block";
      renderSetupPanel();
    });
  }
  if(tabReg){
    // parked
    tabReg.addEventListener("click", ()=>{
      activate(tabTerr);
    });
  }

  // Inputs
  const stWE = document.getElementById("stWE");
  const stEE = document.getElementById("stEE");
  const stNA = document.getElementById("stNA");
  const stPA = document.getElementById("stPA");
  const btnAdd = document.getElementById("btnAddFaction");
  const btnClear = document.getElementById("btnClearFactionSel");
  const btnLock = document.getElementById("btnLockSetup");

  const syncTheatreChecks = ()=>{
    const a = state._meta.activeTheatres;
    if(stWE) stWE.checked = !!a.WE;
    if(stEE) stEE.checked = !!a.EE;
    if(stNA) stNA.checked = !!a.NA;
    if(stPA) stPA.checked = !!a.PA;
  };
  const commitTheatreChecks = ()=>{
    state._meta.activeTheatres = {
      WE: !!stWE?.checked,
      EE: !!stEE?.checked,
      NA: !!stNA?.checked,
      PA: !!stPA?.checked
    };
    saveState();
  };
  [stWE,stEE,stNA,stPA].forEach(el=>{
    if(el) el.addEventListener("change", commitTheatreChecks);
  });

  if(btnAdd){
    btnAdd.addEventListener("click", ()=>{
      const nameEl = document.getElementById("newFactionName");
      const colorEl = document.getElementById("newFactionColor");
      const name = (nameEl?.value||"").trim();
      const color = (colorEl?.value||"#888888").trim();
      if(!name) return;
      const id = crypto.randomUUID();
      state._meta.customFactions.push({id, name, color});
      // auto-select newly created
      state._meta.selectedSetupFaction = "custom:"+id;
      if(nameEl) nameEl.value = "";
      saveState();
      renderSetupPanel();
    });
  }
  if(btnClear){
    btnClear.addEventListener("click", ()=>{
      state._meta.selectedSetupFaction = null;
      saveState();
      renderSetupPanel();
    });
  }
  if(btnLock){
    btnLock.addEventListener("click", ()=>{
      if(state._meta.setupLocked) return;
      // Validate: at least one theatre
      const a = state._meta.activeTheatres || {};
      if(!a.WE && !a.EE && !a.NA && !a.PA){
        alert("Select at least one theatre.");
        return;
      }
      // Validate: all custom factions have homelands
      const missing = (state._meta.customFactions||[]).filter(cf => !state._meta.homelands["custom:"+cf.id]);
      if(missing.length){
        alert("Set a Homeland for every custom faction before locking setup.");
        return;
      }
      state._meta.setupLocked = true;
      state._meta.mode = "PLAY";
      saveState();
      // Switch UI to territory tab
      if(tabTerr) tabTerr.click();
      // Re-render fills after locking
      if(typeof rerenderSvgFills === "function") rerenderSvgFills();
      redrawEdges?.();
    });
  }

  syncTheatreChecks();
  if(state._meta.mode !== "SETUP" && !state._meta.setupLocked){
    // default into SETUP only if no prior lock
    state._meta.mode = "SETUP";
    saveState();
  }
}

function renderSetupPanel(){
  const list = document.getElementById("setupFactionList");
  const hint = document.getElementById("setupHint");
  if(!list) return;
  list.innerHTML = "";
  const selected = state._meta.selectedSetupFaction;
  const addItem = (key, name, color, homeland)=>{
    const div = document.createElement("div");
    div.className = "setupFactionItem" + (selected===key ? " active" : "");
    div.innerHTML = `<div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
      <div>
        <div style="font-weight:800; letter-spacing:1px;">
          <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${color};margin-right:8px;border:1px solid rgba(0,0,0,.5);"></span>
          ${escapeHtml(name)}
        </div>
        <div class="hint" style="margin-top:4px;">Homeland: <b>${homeland ? escapeHtml(homeland) : "Not set"}</b></div>
      </div>
      <div style="opacity:.85;">${selected===key ? "✓" : ""}</div>
    </div>`;
    div.addEventListener("click", ()=>{
      state._meta.selectedSetupFaction = key;
      saveState();
      renderSetupPanel();
    });
    list.appendChild(div);
  };

  // Standard factions (optional for GM)
  addItem("allies", "Allies", ownerToColor("allies"), state._meta.homelands["allies"] || null);
  addItem("axis", "Axis", ownerToColor("axis"), state._meta.homelands["axis"] || null);
  addItem("ussr", "USSR", ownerToColor("ussr"), state._meta.homelands["ussr"] || null);

  // Custom factions
  for(const cf of (state._meta.customFactions||[])){
    addItem("custom:"+cf.id, cf.name, cf.color, state._meta.homelands["custom:"+cf.id] || null);
  }

  if(hint){
    if(state._meta.setupLocked){
      hint.textContent = "Setup is locked. You are in PLAY mode.";
    }else{
      hint.textContent = selected ? "Click a territory on the map to set Homeland for the selected faction." : "Select a faction above, then click a territory to set its Homeland.";
    }
  }

  // Update theatre checks
  const a = state._meta.activeTheatres || {};
  const stWE = document.getElementById("stWE");
  const stEE = document.getElementById("stEE");
  const stNA = document.getElementById("stNA");
  const stPA = document.getElementById("stPA");
  if(stWE) stWE.checked = !!a.WE;
  if(stEE) stEE.checked = !!a.EE;
  if(stNA) stNA.checked = !!a.NA;
  if(stPA) stPA.checked = !!a.PA;

  // Disable lock button if already locked
  const btnLock = document.getElementById("btnLockSetup");
  if(btnLock) btnLock.disabled = !!state._meta.setupLocked;
}

// Assign homeland by clicking a territory during SETUP mode.
// Also sets the territory owner to that faction key (and makes it known to that faction).
function handleSetupTerritoryClick(tid){
  if(state._meta.setupLocked) return false;
  if(state._meta.mode !== "SETUP") return false;
  const key = state._meta.selectedSetupFaction;
  if(!key) return false;

  state._meta.homelands[key] = tid;

  // Set initial owner
  const terr = state[tid] || (state[tid] = {});
  terr.owner = key.startsWith("custom:") ? "custom" : key;
  terr.customOwnerId = key.startsWith("custom:") ? key.substring("custom:".length) : null;

  // Make it visible/known to the owning faction (others remain as-is)
  terr.vis = terr.vis || {allies:"Known", axis:"Known", ussr:"Known", custom:"Known"};
  const visKey = terr.owner;
  if(visKey && terr.vis[visKey] !== undefined) terr.vis[visKey] = "Owned";

  saveState();
  renderSetupPanel();
  if(typeof rerenderSvgFills === "function") rerenderSvgFills();
  return true;
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}


function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function resetState(){
  if(!confirm("Reset all campaign state on this device?")) return;
  localStorage.removeItem(STORAGE_KEY);
  state = loadState();
  ensureSetupDefaults();
  wireSetupUI();
  renderSetupPanel();
  applyMode();
  closePanel();
  clearMove();
  renderAll();
}

function exportState(){
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "war_state.json";
  a.click();
  URL.revokeObjectURL(a.href);
}

function importState(){
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "application/json";
  input.onchange = () => {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const parsed = JSON.parse(reader.result);
        const fresh = loadState();
        for(const k of Object.keys(parsed)) fresh[k] = parsed[k];
        state = fresh;
        saveState();
        closePanel();
        renderAll();
      }catch(e){
        alert("Invalid JSON.");
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

/* -------------------------
   Turn + Phase
-------------------------- */
function refreshPhaseUI(){
  const m = state._meta;
  turnPill.textContent = `Turn ${m.turn}`;
  phasePill.textContent = m.phase;
  phaseSel.value = m.phase;
  autoAdvSel.value = m.autoAdvanceTurn ? "on" : "off";

  // Only GM can change phase selector
  phaseSel.disabled = (modeSel.value !== "GM");
  advanceBtn.disabled = (modeSel.value !== "GM");

  // If Ops ended, lock orders (safety)
  if(m.phase !== "Operations"){
    lockOrdersForTurn(m.turn);
  }
}

function setPhase(newPhase, {manual=false}={}){
  const old = state._meta.phase;
  state._meta.phase = newPhase;

  // Auto resource collection at START of Strategic
  if(old !== "Strategic" && newPhase === "Strategic"){
    autoCollectResources();
  }

  // Lock orders when leaving Operations
  if(old === "Operations" && newPhase !== "Operations"){
    lockOrdersForTurn(state._meta.turn);
  }

  saveState();
  refreshPhaseUI();
  refreshOrdersUI();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
}

function advancePhase(){
  const p = state._meta.phase;
  if(p === "Strategic") setPhase("Operations", {manual:true});
  else if(p === "Operations") setPhase("Resolution", {manual:true});
  else {
    // Resolution -> Strategic (next turn if auto)
    if(state._meta.autoAdvanceTurn){
      state._meta.turn += 1;
    }
    setPhase("Strategic", {manual:true});
  }
}

function lockOrdersForTurn(turn){
  const bucket = (state._meta.orders && state._meta.orders[turn]) ? state._meta.orders[turn] : null;
  if(!bucket) return;
  for(const f of Object.keys(bucket)){
    for(const o of bucket[f]){
      o.status = "locked";
    }
  }
  saveState();
}

/* Simple baseline: +1 resource per controlled territory */
function autoCollectResources(){
  const counts = {allies:0, axis:0, ussr:0, custom:0};
  for(const t of TERRS){
    const owner = state[t.id].owner;
    if(counts[owner] !== undefined) counts[owner] += 1;
  }
  for(const f of ["allies","axis","ussr","custom"]){
    state._meta.factions[f].resources += counts[f];
  }
  saveState();
}

/* GM quick adjust (panel faction = either playerFaction in player mode, or current selector in GM) */
function gmAdjustResources(delta){
  if(modeSel.value !== "GM") return;
  const f = playerFactionSel.value;
  state._meta.factions[f].resources = Math.max(0, state._meta.factions[f].resources + delta);
  saveState();
  refreshHQQuick();
}

/* -------------------------
   Ownership + Fog
-------------------------- */
function applyMode(){
  const mode = modeSel.value;
  document.getElementById("gmControls").style.display = (mode==="GM") ? "block" : "none";
  document.getElementById("playerInfo").style.display = (mode==="PLAYER") ? "block" : "none";
  document.getElementById("hqBtns").style.display = (mode==="GM") ? "flex" : "none";
}

function nodeClassFor(owner){ return `node owner-${owner}`; }

function rerenderNodeFog(){
  const mode = modeSel.value;
  const faction = playerFactionSel.value;
  document.querySelectorAll(".node").forEach(el => {
    const tid = el.dataset.id;
    const st = state[tid];
    el.classList.remove("fog-unknown");
    if(mode === "PLAYER"){
      const v = (st && st.vis && st.vis[faction]) ? st.vis[faction] : "Unknown";
      if(v === "Unknown") el.classList.add("fog-unknown");
    }
  });
  if(currentId) refreshPanel(currentId);
}

/* -------------------------
   Render Map
-------------------------- */
function renderAll(){
  document.querySelectorAll(".theatreBody").forEach(b => b.innerHTML = "");
  clearEdges();
  clearHighlights();
  populateOrderDropdowns();

  const byTheatre = {WE:[], EE:[], NA:[], PA:[]};
  for(const t of TERRS) byTheatre[t.theatreKey].push(t);

  for(const key of Object.keys(byTheatre)){
    const body = document.querySelector(`.theatreBody[data-theatre="${key}"]`);
    const list = byTheatre[key];
    list.sort((a,b)=> a.id.localeCompare(b.id));

    list.forEach((t, idx) => {
const [x,y] = POS15[idx] || POS15[POS15.length-1];
      const st = state[t.id];
      const el = document.createElement("div");
      el.className = nodeClassFor(st.owner);
      el.style.left = x + "px";
      el.style.top = y + "px";
      el.textContent = OWNER_ICON[st.owner] || "●";
      el.dataset.id = t.id;
      el.dataset.theatre = key;
      el.title = `${t.id} — ${t.name}`;
      el.addEventListener("click", () => openPanel(t.id));
      body.appendChild(el);
    });
  }

  applyMode();
  refreshPhaseUI();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshHQQuick();
  refreshMoveUI();
  refreshOrdersUI();
}

function clearHighlights(){
  document.querySelectorAll(".node").forEach(n => {
    n.classList.remove("selected");
    n.classList.remove("adjacent");
  });
}

/* --- Adjacency edges --- */
function clearEdges(){
  while(edgesSvg.firstChild) edgesSvg.removeChild(edgesSvg.firstChild);
}
function nodeCenter(id){
   return territoryCenterOnSvg(id);
}

function drawMarker(tid, kind){
  const p = nodeCenter(tid);
  if(!p) return;

  const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx", p.x);
  c.setAttribute("cy", p.y);
  c.setAttribute("r", kind === "hub" ? "6" : "5");
  c.setAttribute("fill", kind === "hub" ? "rgba(233,227,215,.85)" : "rgba(255,220,120,.85)");
  c.setAttribute("stroke", "rgba(0,0,0,.85)");
  c.setAttribute("stroke-width", "1");
  c.setAttribute("class", kind === "hub" ? "hubMarker" : "chokeMarker");
  edgesSvg.appendChild(c);
}

function drawLine(aId, bId, cls){
  const a = nodeCenter(aId), b = nodeCenter(bId);
  if(!a || !b) return;
  const line = document.createElementNS("http://www.w3.org/2000/svg","line");
  line.setAttribute("x1", a.x); line.setAttribute("y1", a.y);
  line.setAttribute("x2", b.x); line.setAttribute("y2", b.y);
  line.setAttribute("class", cls);
  edgesSvg.appendChild(line);
}
function syncEdgesToSvgViewBox(){
  const svg = getSvg();
  if(!svg || !edgesSvg) return;
  const vb = svg.getAttribute('viewBox');
  if(vb) edgesSvg.setAttribute('viewBox', vb);
}

function redrawEdges(){
  edgesSvg.setAttribute("width", board.clientWidth);
  edgesSvg.setAttribute("height", board.clientHeight);
  edgesSvg.setAttribute("viewBox", `0 0 ${board.clientWidth} ${board.clientHeight}`);

  const mode = adjSel.value;
  clearEdges();

  // If anything inserts a background rect, kill it
  edgesSvg.querySelectorAll("rect").forEach(r => r.setAttribute("fill", "none"));

  // Always show key markers (hubs + chokepoints)
  HUBS.forEach(id => drawMarker(id, "hub"));
  for(const [id] of CHOKES) drawMarker(id, "choke");

  if(mode === "off") return;

  if(mode === "always"){
    const seen = new Set();
    for(const t of TERRS){
      for(const n of t.adj){
        const key = [t.id, n].sort().join("|");
        if(seen.has(key)) continue;
        seen.add(key);
        drawLine(t.id, n, "edgeLine");
      }
    }
    return;
  }
  if(currentId) highlightAdjacency(currentId);
}
function highlightAdjacency(id){
  clearEdges();
  clearHighlights();
  const t = byId.get(id);
  if(!t) return;

  const selectedEl = document.querySelector(`.node[data-id="${id}"]`);
  if(selectedEl) selectedEl.classList.add("selected");

  const mode = modeSel.value;
  const faction = playerFactionSel.value;

  for(const n of t.adj){
    const nEl = document.querySelector(`.node[data-id="${n}"]`);
    if(nEl) nEl.classList.add("adjacent");

    let cls = "edgeLine strong";
    if(mode === "PLAYER"){
      const st = state[n];
      const vis = (st && st.vis && st.vis[faction]) ? st.vis[faction] : "Unknown";
      if(vis === "Unknown") cls = "edgeLine dim";
    }
    drawLine(id, n, cls);
  }
}

/* -------------------------
   Panel
-------------------------- */
function openPanel(id){
  currentId = id;
  refreshPanel(id);
  document.getElementById("panel").style.display = "block";

  // Prefill order FROM to selected territory
  document.getElementById("orderFrom").value = id;

  if(adjSel.value === "select") highlightAdjacency(id);
  else{
    clearHighlights();
    const el = document.querySelector(`.node[data-id="${id}"]`);
    if(el) el.classList.add("selected");
  }

  refreshHQQuick();
  refreshMoveUI();
  refreshOrdersUI();
}

function closePanel(){
  currentId = null;
  document.getElementById("panel").style.display = "none";
  clearHighlights();
  redrawEdges();
}

function refreshPanel(id){
  const t = byId.get(id);
  if(!t) return;
  const st = state[id];

  document.getElementById("pTitle").textContent = t.name;
  document.getElementById("pTheatre").textContent = THEATRE_NAME[t.theatreKey];
  document.getElementById("pId").textContent = t.id;

  // adjacency list
 const adjList = document.getElementById("adjList");
const land = (t.adjLand || []);
const sea  = (t.adjSea || []);

if(!land.length && !sea.length){
  adjList.textContent = "None";
} else {
  adjList.innerHTML = `
    <div><span class="pill">Land</span> ${land.map(nid => linkSpan(nid)).join(" • ") || "—"}</div>
    <div style="margin-top:6px;"><span class="pill">Sea</span> ${sea.map(nid => linkSpan(nid)).join(" • ") || "—"}</div>
  `;

  // attach click handlers
  [...land, ...sea].forEach(nid => {
    const el = adjList.querySelector(`[data-jump="${nid}"]`);
    if(el){
      el.onclick = () => {
        const nt = byId.get(nid);
        if(!nt) return;
        jumpTheatre(nt.theatreId || nt.theatreKey);
        setTimeout(() => openPanel(nid), 250);
      };
    }
  });
}

function linkSpan(nid){
  const nt = byId.get(nid);
  const label = nt ? `${nid} — ${nt.name}` : nid;
  return `<span class="linkish" data-jump="${nid}">${escapeHtml(label)}</span>`;
}


  // GM fields
  if(modeSel.value === "GM"){
    document.getElementById("ownerSel").value = st.owner;
    document.getElementById("visAllies").value = st.vis.allies || "Known";
    document.getElementById("visAxis").value = st.vis.axis || "Known";
    document.getElementById("visUSSR").value = st.vis.ussr || "Known";
    document.getElementById("visCustom").value = st.vis.custom || "Known";
    document.getElementById("notes").value = st.notes || "";
  }
}

function saveTerritory(){
  if(!currentId) return;
  const st = state[currentId];
  st.owner = document.getElementById("ownerSel").value;
  st.vis = {
    allies: document.getElementById("visAllies").value,
    axis: document.getElementById("visAxis").value,
    ussr: document.getElementById("visUSSR").value,
    custom: document.getElementById("visCustom").value
  };
  st.notes = document.getElementById("notes").value || "";
  saveState();

  const node = document.querySelector(`.node[data-id="${currentId}"]`);
  if(node){
    node.className = nodeClassFor(st.owner);
    node.textContent = OWNER_ICON[st.owner] || "●";
  }
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();
  refreshHQQuick();
}

/* -------------------------
   HQ Quick
-------------------------- */
function refreshHQQuick(){
  const f = playerFactionSel.value;
  const res = state._meta.factions[f].resources;

  let ctrl = 0;
  for(const t of TERRS){
    if(state[t.id].owner === f) ctrl++;
  }

  const phase = state._meta.phase;
  const turn = state._meta.turn;
  const who = (modeSel.value === "GM") ? "GM view" : "Player view";

  document.getElementById("hqQuick").innerHTML =
    `Faction: <b>${f.toUpperCase()}</b> • Resources: <b>${res}</b> • Controlled: <b>${ctrl}</b><br>` +
    `Turn: <b>${turn}</b> • Phase: <b>${phase}</b> • ${who}`;
}

/* -------------------------
   Movement Helper
-------------------------- */
function setMoveFromCurrent(){
  if(!currentId) return;
  moveFrom = currentId;
  if(moveTo && !isAdjacent(moveFrom, moveTo)) moveTo = null;
  refreshMoveUI();
  if(adjSel.value === "select") highlightAdjacency(moveFrom);
}
function trySetMoveToCurrent(){
  if(!currentId) return;
  if(!moveFrom){ setMoveFromCurrent(); return; }
  if(currentId === moveFrom){ moveTo = null; refreshMoveUI(); return; }
  if(isAdjacent(moveFrom, currentId)){
    moveTo = currentId;
    setMoveHint("");
  } else {
    setMoveHint(`Not adjacent: ${moveFrom} → ${currentId}. Choose a highlighted neighbour.`);
    moveTo = null;
  }
  refreshMoveUI();
}
function isAdjacent(a, b){
  const ta = byId.get(a);
  return ta && (ta.adj || []).includes(b);
}
function clearMove(){
  moveFrom = null; moveTo = null;
  setMoveHint("");
  refreshMoveUI();
}
function setMoveHint(msg){ document.getElementById("mvHint").textContent = msg || ""; }

function refreshMoveUI(){
  const fromT = moveFrom ? byId.get(moveFrom) : null;
  const toT = moveTo ? byId.get(moveTo) : null;

  document.getElementById("mvFrom").textContent = fromT ? `${moveFrom} — ${fromT.name}` : "—";
  document.getElementById("mvTo").textContent = toT ? `${moveTo} — ${toT.name}` : "—";

  const optionsEl = document.getElementById("mvOptions");
  optionsEl.innerHTML = "";

  if(moveFrom){
    const ta = byId.get(moveFrom);
    const title = document.createElement("div");
    title.className = "hint";
    title.textContent = "Valid destinations:";
    optionsEl.appendChild(title);

    const list = document.createElement("div");
    (ta.adj || []).forEach((nid, i) => {
      const nt = byId.get(nid);
      const span = document.createElement("span");
      span.className = "linkish";
      span.textContent = `${nid} — ${nt.name}`;
      span.onclick = () => {
        moveTo = nid;
        jumpTheatre(nt.theatreId || nt.theatreKey);
        setTimeout(() => openPanel(nid), 250);
        refreshMoveUI();
      };
      list.appendChild(span);
      if(i < ta.adj.length-1) list.appendChild(document.createTextNode(" • "));
    });
    optionsEl.appendChild(list);

    if(moveTo && !isAdjacent(moveFrom, moveTo)){
      moveTo = null;
      setMoveHint("Destination cleared (not adjacent).");
    }
  } else {
    optionsEl.textContent = "Set an origin to see valid destinations.";
  }
}

function logMove(){
  if(!moveFrom || !moveTo){ setMoveHint("Set both Origin and Destination first."); return; }
  if(!isAdjacent(moveFrom, moveTo)){ setMoveHint("Invalid move (not adjacent)."); return; }

  if(modeSel.value !== "GM"){
    setMoveHint("Player mode: move planned (not logged). Switch to GM to log.");
    return;
  }

  const entry = { turn: state._meta.turn, from: moveFrom, to: moveTo, ts: new Date().toISOString() };
  state._meta.moveLog.push(entry);
  saveState();
  setMoveHint(`Logged: Turn ${entry.turn} — ${entry.from} → ${entry.to}`);
}

/* -------------------------
   Orders System
-------------------------- */
function getOrdersBucket(turn){
  if(!state._meta.orders) state._meta.orders = {};
  if(!state._meta.orders[turn]){
    state._meta.orders[turn] = {allies:[], axis:[], ussr:[], custom:[]};
  } else {
    // backfill factions
    for(const f of ["allies","axis","ussr","custom"]){
      if(!state._meta.orders[turn][f]) state._meta.orders[turn][f] = [];
    }
  }
  return state._meta.orders[turn];
}

function populateOrderDropdowns(){
  const fromSel = document.getElementById("orderFrom");
  const toSel = document.getElementById("orderTo");
  const ids = TERRS.map(t => t.id).sort();

  fromSel.innerHTML = "";
  toSel.innerHTML = "";

  for(const id of ids){
    const t = byId.get(id);
    const opt1 = document.createElement("option");
    opt1.value = id;
    opt1.textContent = `${id} — ${t.name}`;
    fromSel.appendChild(opt1);

    const opt2 = document.createElement("option");
    opt2.value = id;
    opt2.textContent = `${id} — ${t.name}`;
    toSel.appendChild(opt2);
  }
}

function refreshOrdersUI(){
  const turn = state._meta.turn;
  const phase = state._meta.phase;
  const mode = modeSel.value;
  const pf = playerFactionSel.value;

  const hint = document.getElementById("ordersHint");
  const canSubmit = (phase === "Operations");
  if(phase !== "Operations"){
    hint.textContent = `Current phase is ${phase}. Orders are submitted in Operations. In Resolution, orders are revealed.`;
  } else {
    hint.textContent = `Operations Phase: submit secret orders. Orders lock when Ops ends.`;
  }

  // Disable add order UI if not Ops and not GM
  const disableInputs = (!canSubmit && mode !== "GM");
  for(const id of ["orderGeneral","orderType","orderFrom","orderTo","orderCond","orderNotes"]){
    document.getElementById(id).disabled = disableInputs;
  }

  renderOrdersList();
}

function createOrder(){
  const turn = state._meta.turn;
  const phase = state._meta.phase;
  const mode = modeSel.value;
  const pf = playerFactionSel.value;

  if(phase !== "Operations" && mode !== "GM"){
    alert("Orders can only be added in Operations Phase (unless GM).");
    return;
  }

  const general = document.getElementById("orderGeneral").value.trim() || "Unnamed General";
  const type = document.getElementById("orderType").value;
  const from = document.getElementById("orderFrom").value;
  const to = document.getElementById("orderTo").value;
  const cond = document.getElementById("orderCond").value.trim();
  const notes = document.getElementById("orderNotes").value.trim();

  // adjacency validation for relevant types
  const needsTo = !["Hold"].includes(type);
  if(needsTo){
    if(!isAdjacent(from, to)){
      alert(`Invalid: ${type} requires an adjacent target. ${from} → ${to} is not adjacent.`);
      return;
    }
  }

  // binary condition best-effort: just warn if looks like multiple conditions
  const bad = /(\bif\b.*\bif\b)|(\bunless\b.*\bunless\b)/i.test(cond);
  if(cond && bad){
    if(!confirm("Condition looks complex (multiple conditions). Keep it anyway?")) return;
  }

  const bucket = getOrdersBucket(turn);
  const order = {
    id: cryptoId(),
    turn,
    faction: pf,
    general,
    type,
    from,
    to: needsTo ? to : null,
    condition: cond || null,
    notes: notes || null,
    status: (phase === "Operations") ? "draft" : "locked",
    submittedAt: new Date().toISOString()
  };
  bucket[pf].push(order);
  saveState();
  renderOrdersList();
}

function canViewOrder(o){
  const mode = modeSel.value;
  const pf = playerFactionSel.value;
  const phase = state._meta.phase;

  if(mode === "GM") return true;

  // Player sees own faction orders always (even in Operations)
  if(o.faction === pf) return true;

  // Enemy orders visible only in Resolution (and later)
  if(phase === "Resolution") return true;

  return false;
}

function canEditOrder(o){
  const mode = modeSel.value;
  const pf = playerFactionSel.value;
  const phase = state._meta.phase;

  if(mode === "GM") return true;
  if(o.faction !== pf) return false;
  if(phase !== "Operations") return false;
  if(o.status !== "draft") return false;
  return true;
}

function renderOrdersList(){
  const list = document.getElementById("ordersList");
  list.innerHTML = "";

  const turn = state._meta.turn;
  const bucket = getOrdersBucket(turn);

  // Collect orders in display order
  const all = [];
  for(const f of ["allies","axis","ussr","custom"]){
    for(const o of bucket[f]) all.push(o);
  }
  // newest first
  all.sort((a,b) => (b.submittedAt||"").localeCompare(a.submittedAt||""));

  if(all.length === 0){
    const empty = document.createElement("div");
    empty.className = "hint";
    empty.textContent = "No orders yet for this turn.";
    list.appendChild(empty);
    return;
  }

  for(const o of all){
    if(!canViewOrder(o)) continue;

    const card = document.createElement("div");
    card.className = "orderCard";

    const top = document.createElement("div");
    top.className = "orderTop";
    top.innerHTML = `<span>${o.faction.toUpperCase()} • ${o.general}</span><span>${o.status || "draft"}</span>`;
    card.appendChild(top);

    const main = document.createElement("div");
    main.className = "orderMain";
    const toTxt = o.to ? ` → <b>${o.to}</b>` : "";
    const condTxt = o.condition ? `<br><span class="pill">IF</span> ${escapeHtml(o.condition)}` : "";
    const notesTxt = o.notes ? `<br><span class="pill">NOTE</span> ${escapeHtml(o.notes)}` : "";
    main.innerHTML =
      `<b>${o.type}</b> from <b>${o.from}</b>${toTxt}` + condTxt + notesTxt;
    card.appendChild(main);

    const btns = document.createElement("div");
    btns.className = "orderBtns";

    const jumpBtn = document.createElement("button");
    jumpBtn.textContent = "Go To";
    jumpBtn.onclick = () => {
      const t = byId.get(o.from);
      jumpTheatre(t.theatreId || t.theatreKey);
      setTimeout(()=>openPanel(o.from), 250);
    };
    btns.appendChild(jumpBtn);

    if(canEditOrder(o)){
      const delBtn = document.createElement("button");
      delBtn.textContent = "Delete";
      delBtn.onclick = () => deleteOrder(o.id);
      btns.appendChild(delBtn);
    } else {
      const ghost = document.createElement("button");
      ghost.textContent = "Locked";
      ghost.disabled = true;
      btns.appendChild(ghost);
    }

    card.appendChild(btns);
    list.appendChild(card);
  }
}

function deleteOrder(orderId){
  const turn = state._meta.turn;
  const bucket = getOrdersBucket(turn);
  for(const f of ["allies","axis","ussr","custom"]){
    const idx = bucket[f].findIndex(o => o.id === orderId);
    if(idx >= 0){
      if(!canEditOrder(bucket[f][idx])) return;
      bucket[f].splice(idx,1);
      saveState();
      renderOrdersList();
      return;
    }
  }
}

function cryptoId(){
  try{
    return crypto.randomUUID();
  }catch(e){
    return "id-" + Math.random().toString(16).slice(2) + "-" + Date.now();
  }
}
function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}

/* -------------------------
   Init
-------------------------- */
(async function bootstrap(){
  const data = await loadAppTheatres();
  const regionData = await loadRegionGroups();

  // Expose globally for other helpers
  window.DATA = data;

  // Normalise regions: region_groups.json uses {groups:[{id,name,territories:[]}]}
  const groups = (regionData && Array.isArray(regionData.groups)) ? regionData.groups : [];
  window.DATA.regions = groups.map(g=>({
    id: g.id,
    name: g.name || g.id,
    territoryIds: g.territories || g.territoryIds || [],
  }));

  TERRS = buildTerrsFromData(window.DATA);
  byId = new Map(TERRS.map(t => [t.id, t]));
  ensureAdjacencyIfMissing();
  state = loadState();
  ensureSetupDefaults();
  wireSetupUI();
  renderSetupPanel();
  applyMode();

  await loadWorldSvg();
  bindTerritoriesToSvg();
  captureBaseViewBox();

  // Visual layers
  applyHybridPlanningFills();
  applyTerritoryBorders();
  /* regions parked */

  redrawEdges();
  /* regions parked */
  applyMode();
  refreshPhaseUI();
  rerenderSvgFills();
  rerenderNodeFog();
  redrawEdges();

  window.addEventListener("resize", () => {
    redrawEdges();
    /* regions parked */
  });
})();


// ===================== Additions: Homeland markers, secured regions, effects panel, theatre lock =====================

function getFactionName(fid){
  const f = (DATA_LOCAL?.factions || []).find(x => x.id === fid);
  return f?.name || fid;
}

function getHomelands(){
  const list = [];
  for(const [tid, st] of Object.entries(state || {})){
    if(st?.homeland) list.push({ territoryId: tid, factionId: st.homeland });
  }
  return list;
}

function clearOverlayMarks(){
  if(!edgesSvg) return;
  edgesSvg.querySelectorAll('.homelandMark, .homelandRing').forEach(n => n.remove());
}

function drawHomelandMarkers(){
  if(!edgesSvg) return;
  const homes = getHomelands();
  for(const h of homes){
    const c = territoryCenterOnSvg(h.territoryId);
    if(!c) continue;

    const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
    ring.setAttribute('cx', c.x);
    ring.setAttribute('cy', c.y);
    ring.setAttribute('r', 10);
    ring.setAttribute('class','homelandRing');
    edgesSvg.appendChild(ring);

    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute('x', c.x);
    t.setAttribute('y', c.y + 6);
    t.setAttribute('text-anchor','middle');
    t.setAttribute('class','homelandMark');
    t.textContent = "★";
    edgesSvg.appendChild(t);
  }
}

// Region control helper: returns {owner, full}
function regionControl(reg){
  const tids = reg.territoryIds || [];
  if(!tids.length) return { owner:'neutral', full:false };
  const counts = {};
  for(const tid of tids){
    const owner = (state?.[tid]?.owner) || 'neutral';
    counts[owner] = (counts[owner] || 0) + 1;
  }
  // pick dominant non-neutral
  const entries = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
  let owner = entries.length ? entries[0][0] : 'neutral';
  let cnt = entries.length ? entries[0][1] : 0;
  if(owner === 'neutral' && entries.length > 1){
    owner = entries[1][0]; cnt = entries[1][1];
  }
  const full = owner !== 'neutral' && cnt === tids.length;
  return { owner, full };
}


// ---------- Region status: neutral vs contested vs secured ----------
function regionStatus(reg){
  const tids = reg.territoryIds || [];
  if(!tids.length) return { status:'neutral', owner:'neutral', full:false };

  const counts = {};
  for(const tid of tids){
    const owner = (state?.[tid]?.owner) || 'neutral';
    counts[owner] = (counts[owner] || 0) + 1;
  }
  const nonNeutralOwners = Object.keys(counts).filter(o => o !== 'neutral' && counts[o] > 0);

  if(nonNeutralOwners.length === 0){
    return { status:'neutral', owner:'neutral', full:false };
  }
  if(nonNeutralOwners.length > 1){
    return { status:'contested', owner:'contested', full:false };
  }
  const owner = nonNeutralOwners[0];
  const full = counts[owner] === tids.length;
  return { status: full ? 'secured' : 'contested', owner, full };
}


// Patch redrawRegions to mark secured regions

const _origRedrawRegions2 = redrawRegions;
redrawRegions = function(){
  _origRedrawRegions2();

  const show = document.getElementById('regionsView')?.checked;
  if(!show || !edgesSvg) return;

  const boxes = Array.from(edgesSvg.querySelectorAll('rect.regionBox'));
  const labels = Array.from(edgesSvg.querySelectorAll('text.regionLabel'));

  // clear status classes
  boxes.forEach(b => b.classList.remove('secured','contested','neutral'));
  labels.forEach(l => l.classList.remove('secured','contested','neutral'));

  let idx = 0;
  const theatreIds = (focusedTheatre ? [focusedTheatre] : (DATA?.theatres||[]).map(t=>t.theatreId));
  for(const thId of theatreIds){
    const th = (DATA?.theatres||[]).find(t=>t.theatreId===thId);
    for(const reg of (th?.regions || [])){
      const st = regionStatus(reg);
      if(boxes[idx]) boxes[idx].classList.add(st.status);
      if(labels[idx]) labels[idx].classList.add(st.status);
      idx += 1;
    }
  }
};


// Effects panel: show active full-control bonuses + homeland-region bonus

function computeContestedRegions(){
  const DATA_LOCAL = window.DATA || (typeof DATA!=='undefined' ? DATA : null);
  if(!DATA_LOCAL) return [];

  const list = [];
  for(const th of (DATA_LOCAL?.theatres || [])){
    if(!activeTheatres?.has(th.theatreId)) continue;
    for(const reg of (th.regions || [])){
      const st = regionStatus(reg);
      if(st.status === 'contested'){
        list.push({label: reg.title, theatre: th.theatreId});
      }
    }
  }
  return list;
}

function computeActiveEffects(){
  const effects = [];

  // full regions
  for(const th of (DATA_LOCAL?.theatres || [])){
    if(!activeTheatres?.has(th.theatreId)) continue;
    for(const reg of (th.regions || [])){
      const st = regionControl(reg);
      if(st.full){
        effects.push({
          type:'REGION',
          owner: st.owner,
          label: reg.title,
          effect: reg.fullControlBonus?.effect || ''
        });
      }
    }
  }

  // homeland-region bonus (per setup rule): if homeland territory still controlled by its faction owner
  const homes = getHomelands();
  for(const h of homes){
    const tid = h.territoryId;
    const fac = (DATA_LOCAL?.factions || []).find(x=>x.id===h.factionId);
    const neededOwner = fac?.defaultOwnerKey || 'neutral';
    const owner = (state?.[tid]?.owner) || 'neutral';
    if(owner === neededOwner){
      const reg = TERRITORY_TO_REGION.get(tid);
      effects.push({
        type:'HOMELAND',
        owner: owner,
        label: `${getFactionName(h.factionId)} Homeland`,
        effect: '+1 Requisition (Homeland held)'
      });
    }
  }

  return effects;
}

function renderEffectsPanel(){
  const panel = document.getElementById('effectsPanel');
  if(!panel) return;
  const show = window.__effectsVisible === true;
  if(!show){ panel.style.display='none'; return; }

  const list = computeActiveEffects();
  panel.style.display='block';

  let html = `<h4>ACTIVE EFFECTS</h4>`;
  if(!list.length){
    html += `<div class="row"><span class="tag">None</span><span class="effect"></span></div>`;
    panel.innerHTML = html;
    return;
  }

  for(const e of list){
    html += `<div class="row">
      <span class="tag">${e.type === 'REGION' ? 'REGION' : 'HOME'}</span>
      <span class="owner">${e.owner}</span>
      <span class="effect">${e.label}${e.effect ? ' — ' + e.effect : ''}</span>
    </div>`;
  }
  panel.innerHTML = html;
}
  const contested = computeContestedRegions();
  if(contested.length){
    html += `<h4 style="margin-top:10px;">CONTESTED REGIONS</h4>`;
    for(const c of contested){
      html += `<div class="row"><span class="tag">${c.theatre}</span><span class="effect">${c.label}</span></div>`;
    }
    panel.innerHTML = html;
  }


// Make sure overlays (regions, edges, homelands) stay aligned
function redrawAllOverlays(){
  (typeof syncEdgesViewBox === 'function' ? syncEdgesViewBox() : void 0);
  redrawEdges();
  /* regions parked */
  clearOverlayMarks();
  drawHomelandMarkers();
  renderEffectsPanel();
}

// Patch places that change view/state
const _origAnimateViewBox = animateViewBox;
animateViewBox = function(svg, from, to, ms){
  _origAnimateViewBox(svg, from, to, ms);
  // edges sync happens in redrawEdges; keep light here
};

// ---- Theatre Lock ----
function setTheatreLock(on){
  localStorage.setItem('WAR_THEATRE_LOCK', on ? '1' : '0');
  document.querySelectorAll('.thSel').forEach(cb => cb.disabled = !!on);
}
function getTheatreLock(){
  return localStorage.getItem('WAR_THEATRE_LOCK') === '1';
}
function initTheatreLock(){
  const box = document.getElementById('theatreLock');
  if(!box) return;
  box.checked = getTheatreLock();
  setTheatreLock(box.checked);
  box.addEventListener('change', () => setTheatreLock(box.checked));
}

// Wire effects toggle
function initEffectsToggle(){
  const btn = document.getElementById('btnEffectsToggle');
  if(!btn) return;
  window.__effectsVisible = (localStorage.getItem('WAR_EFFECTS_VISIBLE') ?? '1') === '1';
  btn.textContent = window.__effectsVisible ? 'Effects: ON' : 'Effects: OFF';
  renderEffectsPanel();
  btn.addEventListener('click', () => {
    window.__effectsVisible = !window.__effectsVisible;
    localStorage.setItem('WAR_EFFECTS_VISIBLE', window.__effectsVisible ? '1' : '0');
    btn.textContent = window.__effectsVisible ? 'Effects: ON' : 'Effects: OFF';
    renderEffectsPanel();
  });
}

// Extend existing wireSetupUI (if present)
const _origWireSetupUI = (typeof wireSetupUI === 'function') ? wireSetupUI : null;
wireSetupUI = function(){
  if(_origWireSetupUI) _origWireSetupUI();
  initTheatreLock();
  initEffectsToggle();

  // After any selection change/redraw, keep overlays updated
  const _oldSaveState = saveState;
  saveState = function(){
    _oldSaveState();
    redrawAllOverlays();
  };

  // Also redraw overlays after setup view toggle
  document.getElementById('setupView')?.addEventListener('change', () => {
    rerenderSvgFills();
    redrawAllOverlays();
  });

  // After theatre changes, update overlays
  document.querySelectorAll('.thSel').forEach(cb => cb.addEventListener('change', () => {
    applyActiveTheatres();
    redrawAllOverlays();
  }));
};

// Ensure buildRegionMaps also triggers overlays
const _origBuildRegionMaps = buildRegionMaps;
buildRegionMaps = function(){
  _origBuildRegionMaps();
  redrawAllOverlays();
};


// ---------- Zoom controls (works even when theatres are locked) ----------
function zoomBy(factor){
  const svg = getSvg();
  if(!svg) return;
  let vb = getViewBox(svg);
  if(!vb){
    const bb = svg.getBBox?.();
    if(!bb) return;
    svg.setAttribute('viewBox', [bb.x, bb.y, bb.width||1, bb.height||1].join(' '));
    vb = getViewBox(svg);
  }
  if(!vb) return;
  const [x,y,w,h] = vb;
  const cx = x + w/2, cy = y + h/2;
  const nw = w * factor, nh = h * factor;
  const to = [cx - nw/2, cy - nh/2, nw, nh];
  animateViewBox(svg, vb, to, 180);
  (typeof syncEdgesViewBox === 'function' ? syncEdgesViewBox() : void 0);
}
function wireZoomUI(){
  document.getElementById('btnZoomIn')?.addEventListener('click', () => zoomBy(0.85));
  document.getElementById('btnZoomOut')?.addEventListener('click', () => zoomBy(1.15));
  document.getElementById('btnZoomReset')?.addEventListener('click', () => { fitWorldToActive(); (typeof syncEdgesViewBox === 'function' ? syncEdgesViewBox() : void 0); (typeof redrawAllOverlays === 'function' ? redrawAllOverlays() : void 0); });
}


// ===================== Setup Checklist Panel =====================
function theatreLabel(id){
  return ({WE:'W. Europe', EE:'E. Europe', NA:'N. Africa', PA:'Pacific'})[id] || id;
}
function computeSetupChecklist(){
  const DATA_LOCAL = window.DATA || (typeof DATA!=='undefined' ? DATA : null);
  DATA = window.DATA || (typeof DATA!=='undefined' ? DATA : null);

  const checklist = [];

  // Theatres
  const selected = Array.from(document.querySelectorAll('.thSel:checked')).map(x=>x.value);
  const lock = document.getElementById('theatreLock')?.checked ? true : false;
  checklist.push({
    label: 'Theatres Selected',
    value: selected.length ? selected.map(theatreLabel).join(', ') : 'None',
    status: selected.length ? 'ok' : 'bad'
  });
  checklist.push({
    label: 'Theatres Locked',
    value: lock ? 'Yes' : 'No',
    status: lock ? 'ok' : 'warn'
  });

  // Setup mode
  const setupOn = document.getElementById('setupView')?.checked ? true : false;
  checklist.push({
    label: 'Setup View',
    value: setupOn ? 'ON' : 'OFF',
    status: setupOn ? 'ok' : 'warn'
  });

  // Factions picked & homelands
  const facCount = (DATA_LOCAL?.factions || []).length;
  const homes = getHomelands();
  checklist.push({
    label: 'Factions Available',
    value: String(facCount),
    status: facCount ? 'ok' : 'bad'
  });

  // Count unique factions with a homeland
  const set = new Set(homes.map(h => h.factionId));
  checklist.push({
    label: 'Homelands Set',
    value: homes.length ? `${set.size} faction(s)` : 'None',
    status: homes.length ? 'ok' : 'bad'
  });

  // Missing homelands
  const missing = (DATA_LOCAL?.factions || []).filter(f => !set.has(f.id)).map(f => f.name);
  checklist.push({
    label: 'Missing Homelands',
    value: missing.length ? missing.join(', ') : 'None',
    status: missing.length ? 'warn' : 'ok'
  });

  // Contested regions warning
  const contested = computeContestedRegions?.() || [];
  checklist.push({
    label: 'Contested Regions',
    value: contested.length ? contested.map(c => `${c.theatre}:${c.label}`).join(' | ') : 'None',
    status: contested.length ? 'warn' : 'ok'
  });

  return checklist;
}

function renderSetupPanel(){
  const panel = document.getElementById('setupPanel');
  if(!panel) return;

  const show = window.__setupVisible === true;
  if(!show){ panel.style.display='none'; return; }

  const list = computeSetupChecklist();
  panel.style.display='block';

  let html = `<h4>SETUP CHECKLIST</h4>`;
  for(const it of list){
    const cls = it.status === 'ok' ? 'ok' : (it.status === 'warn' ? 'warn' : 'bad');
    const sym = it.status === 'ok' ? '✔' : (it.status === 'warn' ? '!' : '✖');
    html += `<div class="item">
      <span>${it.label}</span>
      <span class="${cls}">${sym} ${it.value}</span>
    </div>`;
  }
  panel.innerHTML = html;
}

function initSetupToggle(){
  const btn = document.getElementById('btnSetupToggle');
  if(!btn) return;
  window.__setupVisible = (localStorage.getItem('WAR_SETUP_VISIBLE') ?? '1') === '1';
  btn.textContent = window.__setupVisible ? 'Setup: ON' : 'Setup: OFF';
  renderSetupPanel();
  btn.addEventListener('click', () => {
    window.__setupVisible = !window.__setupVisible;
    localStorage.setItem('WAR_SETUP_VISIBLE', window.__setupVisible ? '1' : '0');
    btn.textContent = window.__setupVisible ? 'Setup: ON' : 'Setup: OFF';
    renderSetupPanel();
  });
}

// Extend existing effects toggle init point
const _origInitEffectsToggle = initEffectsToggle;
initEffectsToggle = function(){
  _origInitEffectsToggle();
  initSetupToggle();
  renderSetupPanel();
};

// Ensure setup panel rerenders when overlays rerender
const _origRenderEffectsPanel2 = renderEffectsPanel;
renderEffectsPanel = function(){
  _origRenderEffectsPanel2();
  renderSetupPanel();
};


// ---------- Theatre buttons: shift-click to toggle active theatres ----------
function handleTheatreBtn(ev, theatreId){
  try{
    if(ev && ev.shiftKey){
      const cb = document.querySelector(`.thSel[value="${theatreId}"]`);
      if(cb && !cb.disabled){
        cb.checked = !cb.checked;
      } else if(cb && cb.disabled){
        // if theatres locked, still allow shift-click to change focus only (no toggle)
        jumpTheatre(theatreId);
        return;
      }
      applyActiveTheatres();
      (typeof redrawAllOverlays === 'function' ? redrawAllOverlays() : void 0);
      return;
    }
  }catch(_){}
  jumpTheatre(theatreId);
}

// Small tooltip hint
(function(){
  const btns = Array.from(document.querySelectorAll('button[onclick^="handleTheatreBtn"]'));
  btns.forEach(b=>{
    const prev = b.getAttribute('title') || '';
    b.setAttribute('title', (prev ? prev + " • " : "") + "Shift-click: add/remove theatre from active set");
  });
})();


// ---------- resetState shim (in case base function name differs) ----------
if(typeof resetState !== 'function'){
  function resetState(){
    try{
      const keys = Object.keys(localStorage).filter(k =>
        k.startsWith('WAR_') || k.startsWith('WAR!') || k.includes('War-Campaign') || k.includes('WAR_STATE')
      );
      keys.forEach(k => localStorage.removeItem(k));
    }catch(_){}
    try{
      if(typeof state !== 'undefined'){
        for(const k of Object.keys(state)) delete state[k];
      }
      window.state = {};
    }catch(_){}
    try{ location.reload(); }catch(_){}
  }
}


// ===================== ViewBox NaN hard-stop patch =====================
function isValidVB(vb){
  return Array.isArray(vb) && vb.length===4 && vb.every(n => Number.isFinite(n)) && vb[2] > 0 && vb[3] > 0;
}
function vbFromBBox(svg){
  try{
    const bb = svg.getBBox?.();
    if(!bb) return null;
    const w = (bb.width && bb.width>0) ? bb.width : 1;
    const h = (bb.height && bb.height>0) ? bb.height : 1;
    return [bb.x, bb.y, w, h];
  }catch(_){ return null; }
}
function safeAnimateViewBox(svg, from, to, ms){
  if(!svg) return;
  // sanitize from/to
  let f = from, t = to;
  if(!isValidVB(f)) f = getViewBox(svg) || vbFromBBox(svg);
  if(!isValidVB(t)) t = vbFromBBox(svg) || f;
  if(!isValidVB(f) || !isValidVB(t)) return;

  // if base animateViewBox exists, use it; else set directly
  if(typeof animateViewBox === 'function'){
    try{
      animateViewBox(svg, f, t, ms || 200);
      return;
    }catch(_){}
  }
  svg.setAttribute('viewBox', t.join(' '));
}

// Wrap resetWorldView to never send NaN
(function(){
  const _origResetWorldView = (typeof resetWorldView === 'function') ? resetWorldView : null;
  if(_origResetWorldView){
    resetWorldView = function(){
      const svg = getSvg();
      if(!svg) return;
      try{
        // Prefer fitWorldToActive if available
        if(typeof fitWorldToActive === 'function'){
          fitWorldToActive();
          const vb = getViewBox(svg) || vbFromBBox(svg);
          if(vb) svg.setAttribute('viewBox', vb.join(' '));
          (typeof syncEdgesViewBox === 'function' ? syncEdgesViewBox() : void 0);
          (typeof redrawAllOverlays === 'function' ? redrawAllOverlays() : void 0);
          return;
        }
      }catch(_){}
      // Fallback: just set to bbox
      const vb = vbFromBBox(svg);
      if(vb) svg.setAttribute('viewBox', vb.join(' '));
      (typeof syncEdgesViewBox === 'function' ? syncEdgesViewBox() : void 0);
      (typeof redrawAllOverlays === 'function' ? redrawAllOverlays() : void 0);
    };
  }
})();

// Wrap any overridden animateViewBox (we added earlier) so it cannot emit NaN
(function(){
  if(typeof animateViewBox !== 'function') return;
  const _avb = animateViewBox;
  animateViewBox = function(svg, from, to, ms){
    if(!svg) return;
    if(!isValidVB(from) || !isValidVB(to)){
      return safeAnimateViewBox(svg, from, to, ms);
    }
    return _avb(svg, from, to, ms);
  };
})();

// ===================== Better Zoom/Pan (wheel + drag) =====================
(function(){
  function getStage(){ return document.getElementById('svgHost'); }
  function getSvgEl(){ return (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg'); }

  function parseVB(svg){
    const vb = (svg && svg.getAttribute('viewBox')) || '';
    const parts = vb.split(/\s+/).map(Number);
    if(parts.length===4 && parts.every(n => Number.isFinite(n)) && parts[2] > 0 && parts[3] > 0) return parts;
    try{
      const bb = svg.getBBox();
      return [bb.x, bb.y, Math.max(1, bb.width), Math.max(1, bb.height)];
    }catch(_){ return [0,0,1000,500]; }
  }

  function setVB(svg, vb){
    if(!svg) return;
    if(!Array.isArray(vb) || vb.length !== 4) return;
    if(!vb.every(n => Number.isFinite(n))) return;
    if(vb[2] <= 0 || vb[3] <= 0) return;
    svg.setAttribute('viewBox', vb.join(' '));
    if(typeof syncEdgesViewBox === 'function') syncEdgesViewBox();
  }

  function clientToSvg(svg, clientX, clientY){
    try{
      const pt = svg.createSVGPoint();
      pt.x = clientX; pt.y = clientY;
      const m = svg.getScreenCTM();
      if(!m) return null;
      return pt.matrixTransform(m.inverse());
    }catch(_){ return null; }
  }

  let dragging = false;
  let last = null;

  function onWheel(e){
    const svg = getSvgEl();
    if(!svg) return;
    e.preventDefault();
    const vb = parseVB(svg);
    const factor = e.deltaY > 0 ? 1.12 : 0.89;

    const p = clientToSvg(svg, e.clientX, e.clientY);
    if(!p) return;

    const [x,y,w,h] = vb;
    const nx = p.x - (p.x - x) * factor;
    const ny = p.y - (p.y - y) * factor;
    const nw = w * factor;
    const nh = h * factor;

    setVB(svg, [nx, ny, nw, nh]);
    if(typeof redrawAllOverlays === 'function') redrawAllOverlays();
  }

  function onDown(e){
    if(e.button !== 0) return;
    const svg = getSvgEl();
    if(!svg) return;
    dragging = true;
    last = { x: e.clientX, y: e.clientY, vb: parseVB(svg) };
    const stage = getStage();
    if(stage) stage.style.cursor = 'grabbing';
  }

  function onMove(e){
    if(!dragging || !last) return;
    const svg = getSvgEl();
    if(!svg) return;
    const rect = svg.getBoundingClientRect();
    const [x,y,w,h] = last.vb;
    const dx = (e.clientX - last.x) * (w / rect.width);
    const dy = (e.clientY - last.y) * (h / rect.height);
    setVB(svg, [x - dx, y - dy, w, h]);
    if(typeof redrawAllOverlays === 'function') redrawAllOverlays();
  }

  function onUp(){
    dragging = false;
    last = null;
    const stage = getStage();
    if(stage) stage.style.cursor = 'default';
  }

  function wire(){
    const stage = getStage();
    if(!stage) return;
    stage.addEventListener('wheel', onWheel, { passive: false });
    stage.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }

  function wireButtons(){
    const zIn = document.getElementById('btnZoomIn');
    const zOut = document.getElementById('btnZoomOut');
    const zFit = document.getElementById('btnZoomReset');

    if(zIn) zIn.addEventListener('click', () => {
      if(typeof zoomBy === 'function') return zoomBy(0.85);
      const s = getSvgEl(); if(!s) return;
      const vb = parseVB(s);
      setVB(s, [vb[0] + vb[2]*0.075, vb[1] + vb[3]*0.075, vb[2]*0.85, vb[3]*0.85]);
      if(typeof redrawAllOverlays === 'function') redrawAllOverlays();
    });

    if(zOut) zOut.addEventListener('click', () => {
      if(typeof zoomBy === 'function') return zoomBy(1.15);
      const s = getSvgEl(); if(!s) return;
      const vb = parseVB(s);
      setVB(s, [vb[0] - vb[2]*0.075, vb[1] - vb[3]*0.075, vb[2]*1.15, vb[3]*1.15]);
      if(typeof redrawAllOverlays === 'function') redrawAllOverlays();
    });

    if(zFit) zFit.addEventListener('click', () => {
      if(typeof fitWorldToActive === 'function') fitWorldToActive();
      else if(typeof resetWorldView === 'function') resetWorldView();
      const s = getSvgEl(); if(!s) return;
      const vb = parseVB(s);
      setVB(s, vb);
      if(typeof redrawAllOverlays === 'function') redrawAllOverlays();
    });
  }

  if(typeof afterSvgLoad === 'function'){
    const _orig = afterSvgLoad;
    afterSvgLoad = function(){
      _orig();
      wire();
      wireButtons();
    };
  } else {
    window.addEventListener('load', () => { wire(); wireButtons(); });
  }
})();


// ===================== Setup Mode UI wiring =====================
function applySetupModeUI(){
  const on = !!document.getElementById('setupView')?.checked;
  document.body.classList.toggle('setup-active', on);

  // Clear lingering adjacency lines when switching modes/views
  if(typeof clearEdges === 'function') clearEdges();
  if(typeof redrawAllOverlays === 'function') redrawAllOverlays();
  if(typeof renderSetupPanel === 'function') renderSetupPanel();
}

// hook setupView toggle
(function(){
  const cb = document.getElementById('setupView');
  if(cb){
    cb.addEventListener('change', applySetupModeUI);
  }
  window.addEventListener('load', applySetupModeUI);
})();


// ===================== Regions (Stage A) =====================
const DEFAULT_REGIONS = [
  // WE
  {id:"R-WE-01", name:"British Isles", theatreId:"WE", territories:["WE-01","WE-02","WE-03"], bonus:"+1 Resource each Strategic Turn while controlled."},
  {id:"R-WE-02", name:"France", theatreId:"WE", territories:["WE-04","WE-05","WE-06"], bonus:"+1 Resource; once per turn you may re-roll one Event."},
  {id:"R-WE-03", name:"Low Countries", theatreId:"WE", territories:["WE-07"], bonus:"+1 Intel token each turn while controlled."},
  {id:"R-WE-04", name:"Germany", theatreId:"WE", territories:["WE-08","WE-09"], bonus:"+2 Resources each turn while controlled (industry)."},
  {id:"R-WE-05", name:"Italy", theatreId:"WE", territories:["WE-10","WE-11"], bonus:"+1 Resource; naval/air staging benefit (placeholder)."},
  {id:"R-WE-06", name:"Alpine Front", theatreId:"WE", territories:["WE-12"], bonus:"Defensive benefit in battles fought here (placeholder)."},
  {id:"R-WE-07", name:"Scandinavia", theatreId:"WE", territories:["WE-13","WE-15"], bonus:"+1 Resource OR +1 Intel each turn (choose)."},
  {id:"R-WE-08", name:"Iberia & Gibraltar", theatreId:"WE", territories:["WE-14"], bonus:"Control of straits/logistics benefit (placeholder)."},

  // EE
  {id:"R-EE-01", name:"Nordic Front", theatreId:"EE", territories:["EE-01","EE-02"], bonus:"Winter warfare readiness (placeholder)."},
  {id:"R-EE-02", name:"Poland", theatreId:"EE", territories:["EE-07","EE-08"], bonus:"+1 Resource; faster redeploy across this region (placeholder)."},
  {id:"R-EE-03", name:"Western USSR", theatreId:"EE", territories:["EE-03","EE-04","EE-05","EE-06"], bonus:"+2 Resources while controlled (strategic depth)."},
  {id:"R-EE-04", name:"Ukraine", theatreId:"EE", territories:["EE-09","EE-10","EE-11"], bonus:"+1 Resource; grain/oil logistics (placeholder)."},
  {id:"R-EE-05", name:"Southern Front", theatreId:"EE", territories:["EE-12","EE-13","EE-14","EE-15"], bonus:"+1 Resource; access to special operations (placeholder)."},

  // NA
  {id:"R-NA-01", name:"Maghreb (Morocco–Tunisia)", theatreId:"NA", territories:["NA-01","NA-02","NA-03","NA-04","NA-05"], bonus:"+1 Resource; port supply advantage (placeholder)."},
  {id:"R-NA-02", name:"Libya", theatreId:"NA", territories:["NA-06","NA-07","NA-08","NA-09","NA-10","NA-11","NA-12"], bonus:"+2 Resources (desert logistics hubs) (placeholder)."},
  {id:"R-NA-03", name:"Egypt & Suez", theatreId:"NA", territories:["NA-13","NA-14","NA-15"], bonus:"+2 Resources while controlled (Suez strategic)."},

  // PA
  {id:"R-PA-01", name:"Japanese Home Islands", theatreId:"PA", territories:["PA-01","PA-02","PA-03"], bonus:"+2 Resources; homeland defence benefit (placeholder)."},
  {id:"R-PA-02", name:"Philippines", theatreId:"PA", territories:["PA-05","PA-06"], bonus:"+1 Resource; forward naval base (placeholder)."},
  {id:"R-PA-03", name:"SE Asia (Malaya–Indochina)", theatreId:"PA", territories:["PA-07","PA-08"], bonus:"+1 Resource; supply routes (placeholder)."},
  {id:"R-PA-04", name:"Dutch East Indies", theatreId:"PA", territories:["PA-09","PA-10","PA-11"], bonus:"+2 Resources (oil) while controlled."},
  {id:"R-PA-05", name:"South/Central Pacific", theatreId:"PA", territories:["PA-12","PA-13","PA-14"], bonus:"+1 Intel each turn while controlled."},
  {id:"R-PA-06", name:"Australia", theatreId:"PA", territories:["PA-15"], bonus:"+1 Resource; staging area (placeholder)."}
];

function getRegions(){
  const d = window.DATA || null;
  if(!d) return [];
  const regions = Array.isArray(d.regions) ? d.regions : [];
  const terrToTheatre = new Map();
  for(const th of (d.theatres||[])){
    for(const t of (th.territories||[])) terrToTheatre.set(t.id, th.theatreId);
  }
  return regions.map(r=>{
    const territoryIds = r.territoryIds || [];
    const theatres = new Set(territoryIds.map(tid=>terrToTheatre.get(tid)).filter(Boolean));
    return {
      ...r,
      territories: territoryIds,
      theatreId: theatres.size ? Array.from(theatres).join(',') : 'Mixed',
    };
  });
}


function ownerOf(tid){
  const st = state?.[tid];
  return (st && st.owner) ? st.owner : "neutral";
}

function computeRegionStatus(region){
  const owners = new Set();
  let ownedCount = 0;
  for(const tid of region.territories){
    const o = ownerOf(tid);
    if(o && o !== "neutral"){
      owners.add(o);
      ownedCount++;
    }
  }
  if(ownedCount === 0) return {status:"Neutral", cls:"neut", owner:"—"};
  if(owners.size >= 2) return {status:"Contested", cls:"cont", owner:"Mixed"};
  const sole = [...owners][0];
  // controlled only if ALL territories are owned by sole
  const allOwnedBySole = region.territories.every(t => ownerOf(t) === sole);
  if(allOwnedBySole) return {status:"Controlled", cls:"ctrl", owner:sole.toUpperCase()};
  return {status:"Partial", cls:"part", owner:sole.toUpperCase()};
}

function clearRegionHighlight(){
  const svg = (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg');
  if(!svg) return;
  svg.querySelectorAll('.region-highlight').forEach(el => el.classList.remove('region-highlight'));
  svg.querySelectorAll('.region-dim').forEach(el => el.classList.remove('region-dim'));
}

function highlightRegion(region){
  if(!region) return;
  currentRegion = region.id;

  const svg = getSvg();
  if(!svg) return;

  const elems = [];
  for(const tid of (region.territories || region.territoryIds || [])){
    const terr = byId.get(tid);
    if(!terr) continue;
    for(const ref of (terr.shapeRefs||[])){
      const el = svg.getElementById ? svg.getElementById(ref) : svg.querySelector(`#${CSS.escape(ref)}`);
      if(el) elems.push(el);
    }
  }
  const bb = bboxForElements(elems);
  if(!bb) return;

  // pad for readability
  const pad = 16;
  const target = {
    x: Math.max(0, bb.x - pad),
    y: Math.max(0, bb.y - pad),
    w: bb.width + pad*2,
    h: bb.height + pad*2,
  };
  animateViewBox(getSvg(), target.x, target.y, target.w, target.h, 420);
  syncEdgesToSvgViewBox();
  /* regions parked */
}


function renderRegionList(){
  const host = document.getElementById('regionList');
  if(!host) return;
  const regions = getRegions();

  host.innerHTML = `<div id="regionListInner"></div>`;
  const inner = document.getElementById('regionListInner');
  if(!inner) return;

  regions.forEach(r=>{
    const s = computeRegionStatus(r);
    const row = document.createElement('div');
    row.className = 'regionRow';
    row.innerHTML = `
      <div>
        <div class="regionName">${r.name}</div>
        <div class="hint">${r.theatreId} • ${r.territories.length} territories</div>
      </div>
      <div class="regionMeta">
        <span class="badge ${s.cls}">${s.status}</span>
        <span class="badge">${s.owner}</span>
      </div>
    `;
    row.addEventListener('click', ()=> highlightRegion(r));
    inner.appendChild(row);
  });
}

// Tabs wiring
function setPanelTab(which){
  const tBtn = document.getElementById('tabTerritory');
  const rBtn = document.getElementById('tabRegions');
  const tPan = document.getElementById('territoryPanel');
  const rPan = document.getElementById('regionPanel');
  if(!tBtn || !rBtn || !tPan || !rPan) return;

  const isRegions = which === 'regions';
  tBtn.classList.toggle('active', !isRegions);
  rBtn.classList.toggle('active', isRegions);
  tPan.style.display = isRegions ? 'none' : 'block';
  rPan.style.display = isRegions ? 'block' : 'none';

  if(isRegions){
    renderRegionList();
  }else{
    clearRegionHighlight();
  }
}

(function(){
  const tBtn = document.getElementById('tabTerritory');
  const rBtn = document.getElementById('tabRegions');
  if(tBtn) tBtn.addEventListener('click', ()=> setPanelTab('territory'));
  if(rBtn) rBtn.addEventListener('click', ()=> setPanelTab('regions'));

  const dim = document.getElementById('toggleRegionDim');
  if(dim) dim.addEventListener('change', ()=> {
    // re-highlight current selection by re-render list click? simplest: clear dims, keep list
    clearRegionHighlight();
  });

  // Ensure list refreshes when a territory owner changes
  const _origSaveTerritory = (typeof saveTerritory === 'function') ? saveTerritory : null;
  if(_origSaveTerritory){
    saveTerritory = function(){
      _origSaveTerritory();
      // If regions tab open, refresh statuses
      const rPan = document.getElementById('regionPanel');
      if(rPan && rPan.style.display !== 'none'){
        renderRegionList();
      }
    }
  }
})();


// ===================== Territory Pins =====================
const pinsSvg = document.getElementById('pins');

function clearPins(){
  if(!pinsSvg) return;
  while(pinsSvg.firstChild) pinsSvg.removeChild(pinsSvg.firstChild);
}

function ensurePinsViewBox(){
  const svg = (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg');
  if(!svg || !pinsSvg) return;
  pinsSvg.setAttribute('width','100%');
  pinsSvg.setAttribute('height','100%');
  const vb = svg.getAttribute('viewBox');
  if(vb) pinsSvg.setAttribute('viewBox', vb);
  pinsSvg.setAttribute('preserveAspectRatio','xMidYMid meet');
}

function territoryCenterFromElement(el){
  try{
    const bb = el.getBBox();
    return { x: bb.x + bb.width/2, y: bb.y + bb.height/2 };
  }catch(_){ return null; }
}

function renderPins(){
  const toggle = document.getElementById('togglePins');
  if(!toggle || !toggle.checked){ clearPins(); return; }
  const svgDoc = document.querySelector('#svgHost svg');
  if(!svgDoc || !pinsSvg) return;

  ensurePinsViewBox();
  clearPins();

  // Find one representative element per territory id (we already mapped data-territory-id on elements)
  const terrEls = Array.from(svgDoc.querySelectorAll('[data-territory-id]'));
  const seen = new Set();
  for(const el of terrEls){
    const tid = el.getAttribute('data-territory-id');
    if(!tid || seen.has(tid)) continue;
    seen.add(tid);

    const c = territoryCenterFromElement(el);
    if(!c) continue;

    // Dot
    const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
    dot.setAttribute('cx', c.x);
    dot.setAttribute('cy', c.y);
    dot.setAttribute('r', 4.5);
    dot.setAttribute('class','pinDot');
    pinsSvg.appendChild(dot);

    // Label (short id)
    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('x', c.x + 6);
    txt.setAttribute('y', c.y + 3);
    txt.setAttribute('class','pinText');
    txt.textContent = tid;
    pinsSvg.appendChild(txt);
  }
}

(function(){
  const cb = document.getElementById('togglePins');
  if(cb) cb.addEventListener('change', () => { renderPins(); });
  // Re-render pins whenever overlays or view changes
  const _origRedrawAll = (typeof redrawAllOverlays === 'function') ? redrawAllOverlays : null;
  if(_origRedrawAll){
    redrawAllOverlays = function(){
      _origRedrawAll();
      ensurePinsViewBox();
      renderPins();
    };
  }
  // After SVG load, draw pins
  if(typeof afterSvgLoad === 'function'){
    const _origAfter = afterSvgLoad;
    afterSvgLoad = function(){
      _origAfter();
      ensurePinsViewBox();
      renderPins();
    };
  } else {
    window.addEventListener('load', () => { ensurePinsViewBox(); renderPins(); });
  }
})();



// ===================== Regions overlay: always-visible borders =====================
const regionBordersSvg = document.getElementById('regionBorders');

const regionSelectBordersSvg = document.getElementById('regionSelectBorders');
function clearRegionBorders(){
  if(regionBordersSvg){ while(regionBordersSvg.firstChild) regionBordersSvg.removeChild(regionBordersSvg.firstChild); }
}

function clearSelectedRegionBorders(){
  if(regionSelectBordersSvg){ while(regionSelectBordersSvg.firstChild) regionSelectBordersSvg.removeChild(regionSelectBordersSvg.firstChild); }
}


function syncOverlayViewBoxes(){
  const svg = (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg');
  if(!svg) return;
  const vb = svg.getAttribute('viewBox');
  if(vb){
    if(regionBordersSvg){ regionBordersSvg.setAttribute('viewBox', vb); }
    if(typeof syncEdgesViewBox === 'function') syncEdgesViewBox();
    const pinsSvg = document.getElementById('pins');
    if(pinsSvg) pinsSvg.setAttribute('viewBox', vb);
  }
}

function getRegionColor(regionId){
  // Deterministic pastel-ish palette derived from regionId
  const cs = getComputedStyle(document.documentElement);
  const seed = Array.from(String(regionId||'R')).reduce((a,c)=>a + c.charCodeAt(0), 0);
  const hue = (seed * 37) % 360;
  return `hsl(${hue} 45% 55%)`;
}

function redrawRegionBorders(){
  if(!regionBordersSvg) return;
  const hostSvg = (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg');
  if(!hostSvg) return;

  clearRegionBorders();

  const vb = hostSvg.getAttribute('viewBox');
  if(vb) regionBordersSvg.setAttribute('viewBox', vb);
  if(vb && regionSelectBordersSvg) regionSelectBordersSvg.setAttribute('viewBox', vb);

  const data = window.DATA || (typeof DATA !== 'undefined' ? DATA : null);
  if(!data) return;

  const regions = data.regions || [];
  for(const r of regions){
    const rid = (r.regionId || r.id || r.name);
    const color = r.color || getRegionColor(rid);
    const shapeRefs = new Set(r.shapeRefs || []);
    const territoryIds = r.territoryIds || r.territories || [];
    if(shapeRefs.size === 0 && Array.isArray(territoryIds)){
      for(const tid of territoryIds){
        const t = (data.theatres||[]).flatMap(th => th.territories||[]).find(x => x.id===tid);
        if(t && Array.isArray(t.shapeRefs)) t.shapeRefs.forEach(s => shapeRefs.add(s));
      }
    }
    for(const ref of shapeRefs){
      const orig = document.getElementById(ref);
      if(!orig) continue;
      const clone = orig.cloneNode(true);
      clone.setAttribute('fill', 'none');
      clone.setAttribute('stroke', color);
      clone.setAttribute('stroke-width', '1.8');
      clone.setAttribute('class', 'rBorderBase');
      clone.setAttribute('pointer-events', 'none');
      regionBordersSvg.appendChild(clone);
    }
  }
}


// Ensure region borders redraw whenever SVG loads, view changes, or region selection changes
(function(){
  const _origAfterSvgLoad = (typeof afterSvgLoad === 'function') ? afterSvgLoad : null;
  if(_origAfterSvgLoad){
    afterSvgLoad = function(){
      _origAfterSvgLoad();
      /* regions parked */
      syncOverlayViewBoxes();
    };
  } else {
    window.addEventListener('load', () => { /* regions parked */ syncOverlayViewBoxes(); });
  }

  // Patch animate/set viewbox flows to keep overlays aligned
  const _setVB = (typeof setViewBox === 'function') ? setViewBox : null;
  if(_setVB){
    setViewBox = function(vb){
      _setVB(vb);
      syncOverlayViewBoxes();
      /* regions parked */
    };
  }
})();


// ===================== Hybrid planning view: grey fills + visible borders, owned territories colored =====================
function applyHybridPlanningFills(){
  const svg = (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg');
  if(!svg) return;
  const setupOn = !!document.getElementById('setupView')?.checked;
  const data = window.DATA || (typeof DATA !== 'undefined' ? DATA : null);
  const st = window.state || (typeof state !== 'undefined' ? state : null);
  if(!data || !st) return;

  // baseline grey for all shapes we track
  const baseGrey = 'rgb(204, 204, 204)';
  const terrs = (data.theatres||[]).flatMap(th => th.territories||[]);
  for(const t of terrs){
    const owner = (st.owners && st.owners[t.id]) ? st.owners[t.id] : 'neutral';
    const owned = owner && owner !== 'neutral';
    const fill = (setupOn && owned) ? ownerToColor(owner) : baseGrey;

    for(const ref of (t.shapeRefs||[])){
      const el = document.getElementById(ref);
      if(!el) continue;
      el.style.fill = fill;
      el.style.opacity = '1';
      // make borders visible on base shapes too
      el.style.stroke = 'rgba(0,0,0,.55)';
      el.style.strokeWidth = '0.45';
    }
  }
}

function applyTerritoryBorders(){
  const svg = getSvg();
  if(!svg) return;
  const shapes = svg.querySelectorAll('path,polygon,rect');
  shapes.forEach(el=>{
    el.setAttribute('stroke', 'rgba(0,0,0,0.70)');
    el.setAttribute('stroke-width', '0.9');
    el.setAttribute('vector-effect', 'non-scaling-stroke');
  });
}


// Run after any territory save / rerender
(function(){
  const _origSave = (typeof saveTerritory === 'function') ? saveTerritory : null;
  if(_origSave){
    saveTerritory = function(){
      _origSave();
      applyHybridPlanningFills();
      if(typeof renderRegionsPanel === 'function') renderRegionsPanel();
      /* regions parked */
    };
  }
  const _origRer = (typeof rerenderSvgFills === 'function') ? rerenderSvgFills : null;
  if(_origRer){
    rerenderSvgFills = function(){
      _origRer();
      applyHybridPlanningFills();
      /* regions parked */
    };
  }
  window.addEventListener('load', () => {
    applyHybridPlanningFills();
    /* regions parked */
  });
})();


// ===================== Ensure overlays apply after SVG is actually in DOM =====================
function onSvgReady(){
  try{ if(typeof applyHybridPlanningFills === 'function') applyHybridPlanningFills(); }catch(_){}
  try{ if(typeof redrawRegionBorders === 'function') /* regions parked */ }catch(_){}
  try{
    const hostSvg = (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg');
    if(hostSvg && regionBordersSvg){
      const vb = hostSvg.getAttribute('viewBox');
      if(vb) regionBordersSvg.setAttribute('viewBox', vb);
    }
  }catch(_){}
}
window.addEventListener('load', () => setTimeout(onSvgReady, 50));


// ===================== Hard apply territory borders (post-load) =====================
function applyTerritoryBorders(){
  const data = window.DATA || (typeof DATA !== 'undefined' ? DATA : null);
  if(!data) return;
  for(const th of (data.theatres||[])){
    for(const t of (th.territories||[])){
      for(const ref of (t.shapeRefs||[])){
        const el = document.getElementById(ref);
        if(!el) continue;
        el.setAttribute('stroke', 'rgba(0,0,0,.70)');
        el.setAttribute('stroke-width', '0.9');
        el.setAttribute('vector-effect', 'non-scaling-stroke');
      }
    }
  }
}

// Ensure overlays exist + sync viewBoxes
(function(){
  const orig = (typeof afterSvgLoad === 'function') ? afterSvgLoad : null;
  if(orig){
    afterSvgLoad = function(){
      orig();
      applyTerritoryBorders();
      if(typeof redrawRegionBorders === 'function') /* regions parked */
      if(typeof ensurePinsViewBox === 'function') ensurePinsViewBox();
      if(typeof syncEdgesToSvgViewBox === 'function') syncEdgesToSvgViewBox();
    };
  } else {
    window.addEventListener('load', () => {
      setTimeout(() => {
        applyTerritoryBorders();
        if(typeof redrawRegionBorders === 'function') /* regions parked */
      }, 100);
    });
  }
})();


function drawSelectedRegionOverlay(regionId){
  if(!regionSelectBordersSvg) return;
  clearSelectedRegionBorders();
  const hostSvg = (typeof getSvg === 'function' ? getSvg() : null) || document.querySelector('#svgHost svg');
  if(!hostSvg) return;
  const vb = hostSvg.getAttribute('viewBox');
  if(vb) regionSelectBordersSvg.setAttribute('viewBox', vb);

  const data = window.DATA || (typeof DATA !== 'undefined' ? DATA : null);
  if(!data) return;
  const region = (data.regions||[]).find(r => (r.regionId||r.id||r.name) === regionId);
  if(!region) return;

  const color = region.color || getRegionColor(regionId);
  const shapeRefs = new Set(region.shapeRefs || []);
  const territoryIds = region.territoryIds || region.territories || [];
  if(shapeRefs.size === 0 && Array.isArray(territoryIds)){
    for(const tid of territoryIds){
      const t = (data.theatres||[]).flatMap(th => th.territories||[]).find(x => x.id===tid);
      if(t && Array.isArray(t.shapeRefs)) t.shapeRefs.forEach(s => shapeRefs.add(s));
    }
  }

  for(const ref of shapeRefs){
    const orig = document.getElementById(ref);
    if(!orig) continue;
    const clone = orig.cloneNode(true);
    clone.setAttribute('fill','none');
    clone.setAttribute('stroke', color);
    clone.setAttribute('stroke-width','3.4');
    clone.setAttribute('class','rBorderSel');
    clone.setAttribute('pointer-events','none');
    regionSelectBordersSvg.appendChild(clone);
  }
}

</script>
</body>
</html>
